#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Rosalia Labs LLC
#
# Update a remote SensOS client by syncing the current source tree under:
#   client/sensos/stage-base/00-sensos/files/
#
# Rules:
# - Let rsync create missing subdirectories under /sensos (no per-subdir checks).
# - /sensos must already exist on the remote.
# - No silent defaults for required inputs; fail fast with clear errors.
# - Perform a real sync: create/update files and delete removed ones on destination,
#   while excluding data/, keys/, log/, init.d/ from any changes/deletions.

set -euo pipefail
: "${CONTROLLER_CONTAINER:=sensos-controller}"

# ---------- helpers ----------
require_cmd() { command -v "$1" >/dev/null 2>&1 || { echo "Error: required command not found: $1" >&2; exit 127; }; }
require_container_running() {
  local n="$1"
  docker inspect "$n" >/dev/null 2>&1 || { echo "Error: required Docker container not found: $n" >&2; exit 1; }
  [[ "$(docker inspect -f '{{.State.Running}}' "$n" 2>/dev/null)" == "true" ]] || { echo "Error: Docker container is not running: $n" >&2; exit 1; }
}
is_ip() {
  local ip="$1"
  [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
  IFS='.' read -r a b c d <<<"$ip"
  for n in "$a" "$b" "$c" "$d"; do (( n>=0 && n<=255 )) || return 1; done
  return 0
}
hash_octet_from_name() { printf %s "$1" | od -An -t u1 | awk '{for(i=1;i<=NF;i++) s+=$i} END{print s%256}'; }
build_ip_from_token() {
  local tok="$1"
  if [[ ! "$tok" =~ ^([A-Za-z0-9-]+)[_-]([0-9]+)[_-]([0-9]+)$ ]]; then
    echo "Error: invalid token '$tok'. Expected '<net>_<a>_<b>' or '<net>-<a>-<b>'." >&2
    exit 2
  fi
  local net="${BASH_REMATCH[1]}" a="${BASH_REMATCH[2]}" b="${BASH_REMATCH[3]}"
  (( a>=0 && a<=255 )) || { echo "Error: invalid octet $a" >&2; exit 2; }
  (( b>=0 && b<=255 )) || { echo "Error: invalid octet $b" >&2; exit 2; }
  local o2; o2="$(hash_octet_from_name "$net")"
  echo "10.${o2}.${a}.${b}"
}
run_in_controller_as_sensos() {
  local cmd="$1"
  if docker exec "$CONTROLLER_CONTAINER" which sudo >/dev/null 2>&1; then
    docker exec "$CONTROLLER_CONTAINER" sudo -u sensos -- bash -lc "$cmd"
  else
    docker exec "$CONTROLLER_CONTAINER" su -s /bin/bash sensos -c "$cmd"
  fi
}
usage() {
  cat >&2 <<'EOF'
Usage: sensos-update-client <ip-or-token> [--dry-run] [--reboot] [-- <remote post cmd>]
  <ip-or-token>  10.x.y.z OR <net>_<a>_<b> OR <net>-<a>-<b>
  --dry-run      Show what would change without applying
  --reboot       Reboot the remote Pi after sync
  --             Everything after this is run on the remote BEFORE reboot
EOF
  exit 2
}

# ---------- main ----------
main() {
  require_cmd docker; require_cmd od; require_cmd awk; require_cmd tar; require_cmd rsync; require_cmd stat; require_cmd numfmt

  [[ $# -ge 1 ]] || usage
  local target="$1"; shift
  local DRY=0 REBOOT=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run) DRY=1; shift ;;
      --reboot) REBOOT=1; shift ;;
      --) shift; break ;;
      *) break ;;
    esac
  done
  local remote_post_cmd=("$@")  # may be empty

  local ip
  if is_ip "$target"; then ip="$target"; else ip="$(build_ip_from_token "$target")"; fi

  # Infer BASE
  local SCRIPT_DIR BASE_DIR
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  if [[ -z "${BASE:-}" ]]; then
    BASE_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)" || { echo "Error: cannot infer BASE dir." >&2; exit 1; }
  else
    BASE_DIR="$BASE"
  fi

  local SRC_ROOT="${BASE_DIR}/client/sensos/stage-base/00-sensos/files"
  [[ -d "$SRC_ROOT" ]] || { echo "Error: required directory not found: files ($SRC_ROOT)" >&2; exit 1; }

  require_container_running "$CONTROLLER_CONTAINER"
  
  # 1) Pack entire files/ tree
  local TMP_TAR; TMP_TAR="$(mktemp -t sensos-sync.XXXXXX.tar)"
  ( cd "$SRC_ROOT" && tar cf "$TMP_TAR" . )
  local TAR_BYTES; TAR_BYTES="$(stat -c%s "$TMP_TAR" 2>/dev/null || echo 0)"

  # 2) Copy tarball into controller
  local CT_TAR="/tmp/$(basename "$TMP_TAR")"
  docker cp "$TMP_TAR" "$CONTROLLER_CONTAINER:$CT_TAR" || { echo "Error: docker cp to controller failed." >&2; rm -f "$TMP_TAR"; exit 1; }
  rm -f "$TMP_TAR"
  echo "Pushed $(numfmt --to=iec --suffix=B "$TAR_BYTES") to $CONTROLLER_CONTAINER:$CT_TAR"

  # 3) scp tarball to remote
  local REM_TAR="/tmp/$(basename "$CT_TAR")"
  local SSH_OPTS="-o StrictHostKeyChecking=accept-new -o ServerAliveInterval=30 -o ServerAliveCountMax=3"
  run_in_controller_as_sensos "scp $SSH_OPTS '$CT_TAR' 'sensos-admin@${ip}:${REM_TAR}'"

  # 4) Remote: unpack to temp, single rsync with excludes
  local RSYNC_FLAGS="-a --delete-after --checksum"
  (( DRY == 1 )) && RSYNC_FLAGS="--dry-run --itemize-changes $RSYNC_FLAGS"

  local REMOTE_SCRIPT
  read -r -d '' REMOTE_SCRIPT <<EOS
set -euxo pipefail

STAGE_DIR="\$(mktemp -d /tmp/sensos-sync.XXXXXX)"
trap 'rm -rf "\$STAGE_DIR"' EXIT
tar xf "$REM_TAR" -C "\$STAGE_DIR"
rm -f "$REM_TAR"

# Mirror STAGE_DIR -> /sensos while protecting excluded dirs
rsync $RSYNC_FLAGS \
  --exclude='data/' \
  --exclude='keys/' \
  --exclude='log/' \
  --exclude='init.d/' \
  "\$STAGE_DIR/" "/sensos/"

echo "[sensos-update-client] Remote sync complete."
EOS

  local REMOTE_CMD
  REMOTE_CMD="$(printf 'bash -o pipefail -e -u -c %q' "$REMOTE_SCRIPT")"
  run_in_controller_as_sensos "ssh $SSH_OPTS 'sensos-admin@${ip}' $REMOTE_CMD"

  # Optional post-command BEFORE reboot
  if [[ ${#remote_post_cmd[@]} -gt 0 ]]; then
    local Q; Q="$(printf '%q ' "${remote_post_cmd[@]}")"
    run_in_controller_as_sensos "ssh $SSH_OPTS 'sensos-admin@${ip}' bash -o pipefail -e -u -c $Q"
  fi

  # 5) Optional reboot
  if (( REBOOT == 1 )); then
    run_in_controller_as_sensos "ssh $SSH_OPTS 'sensos-admin@${ip}' bash -o pipefail -e -u -c 'echo Rebooting in 3s...; sleep 3; /sbin/reboot || reboot'"
  fi

  # 6) Cleanup tar inside controller
  run_in_controller_as_sensos "rm -f '$CT_TAR' || true"

  echo "âœ” Update completed for ${ip} (dry-run=${DRY}, reboot=${REBOOT})"
}

main "$@"
