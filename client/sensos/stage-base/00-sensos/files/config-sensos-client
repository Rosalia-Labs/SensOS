#!/usr/bin/env python3
import os
import sys
import stat
import argparse
import requests
import datetime
import subprocess
import base64
import json

# Default Configuration
DEFAULT_SERVER = "localhost"
DEFAULT_PORT = "8000"
DEFAULT_NETWORK_NAME = "sensos"
DEFAULT_WG_DIR = "/etc/wireguard"
DEFAULT_KEEPALIVE = "0"

API_KEY_FILE = os.path.expanduser("~/.sensos_api_key")


def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Configure the Sensos WireGuard client."
    )
    parser.add_argument(
        "--server",
        default=DEFAULT_SERVER,
        help="API server hostname or IP (default: localhost)",
    )
    parser.add_argument(
        "--port",
        default=DEFAULT_PORT,
        help="Server port (default: 8000)",
    )
    parser.add_argument(
        "--network", default=DEFAULT_NETWORK_NAME, help="Network name (default: sensos)"
    )
    parser.add_argument(
        "--wg-config-dir",
        default=DEFAULT_WG_DIR,
        help="WireGuard config directory (default: /etc/wireguard)",
    )
    parser.add_argument(
        "--wg-keepalive",
        default=DEFAULT_KEEPALIVE,
        help="WireGuard persistent keepalive interval (default: 0 seconds)",
    )
    parser.add_argument(
        "--subnet",
        type=int,
        default=1,  # Default to starting at x.x.1.1
        help="Subnet offset for WireGuard IP assignment (default: 1, i.e., x.x.1.1)",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force overwrite of existing files and settings",
    )
    parser.add_argument(
        "--enable-ssh-passwords",
        action="store_true",
        help="Enable SSH password authentication (default: disabled)",
    )
    return parser.parse_args()


def run_command(cmd):
    """Runs a shell command and returns its output."""
    return subprocess.run(
        cmd, shell=True, check=True, capture_output=True, text=True
    ).stdout.strip()


def enable_wireguard(netname: str):
    service_name = f"wg-quick@{netname}.service"
    run_command(f"sudo systemctl enable {service_name}")
    run_command(f"sudo systemctl start {service_name}")
    print(f"âœ… WireGuard service {service_name} enabled and started.")


def enable_ssh(passwords: bool = False):
    """Enable SSH and configure password authentication based on the `passwords` flag."""
    sshd_config = "/etc/ssh/sshd_config"
    backup_config = "/etc/ssh/sshd_config.bak"

    # Backup before modifying
    run_command(f"sudo cp -a {sshd_config} {backup_config}")

    # Set password authentication based on flag
    password_setting = "yes" if passwords else "no"
    run_command(
        f"sudo sed -i 's/^#?PasswordAuthentication .*/PasswordAuthentication {password_setting}/' {sshd_config}"
    )

    print(f"âœ… SSH passwords are {'enabled' if passwords else 'disabled'}.")

    # Ensure public key authentication is enabled
    run_command(
        f"sudo sed -i 's/^#?PubkeyAuthentication .*/PubkeyAuthentication yes/' {sshd_config}"
    )

    # Enable and start SSH service
    run_command("sudo systemctl enable ssh")
    run_command("sudo systemctl start ssh")

    print("âœ… SSH service enabled and started.")
    print("ğŸ”„ A reboot is required for changes to fully take effect.")


def get_api_password():
    """Retrieve or prompt for API password, caching it in ~/.sensos_api_key."""
    if os.path.exists(API_KEY_FILE):
        with open(API_KEY_FILE, "r") as f:
            return f.read().strip()

    api_password = input("ğŸ”‘ Enter API password: ").strip()

    with open(API_KEY_FILE, "w") as f:
        f.write(api_password)
    os.chmod(API_KEY_FILE, stat.S_IRUSR | stat.S_IWUSR)

    print(f"âœ… API password saved securely in {API_KEY_FILE}.")
    return api_password


def get_basic_auth(api_password):
    """Encode API password in Basic Auth format."""
    auth_str = f":{api_password}"  # Username is ignored, so empty username
    return base64.b64encode(auth_str.encode()).decode()


def generate_wireguard_keys(wg_config_dir, force):
    """Generate WireGuard key pair if not already present. Returns public key."""

    if not os.path.isdir(wg_config_dir):
        print(
            f"Error: Configuration directory '{wg_config_dir}' does not exist.",
            file=sys.stderr,
        )
        sys.exit(1)

    private_key_file = os.path.join(wg_config_dir, "private.key")
    public_key_file = os.path.join(wg_config_dir, "public.key")

    if os.path.exists(private_key_file) or os.path.exists(public_key_file):
        print("âš ï¸ WireGuard keys already exist.")
        if not force:
            print(
                "ğŸš« Aborting to prevent overwriting existing keys. Use --force to override."
            )
            sys.exit(1)

    print("ğŸ”‘ Generating new WireGuard key pair...")
    private_key = run_command("wg genkey")
    public_key = run_command(f"echo {private_key} | wg pubkey")

    # Write the private key securely using sudo
    run_command(f"echo '{private_key}' | sudo tee {private_key_file} > /dev/null")
    run_command(f"sudo chmod 600 {private_key_file}")

    # Write the public key (less sensitive)
    run_command(f"echo '{public_key}' | sudo tee {public_key_file} > /dev/null")

    print(f"  - Private Key stored in: {private_key_file} (permissions set to 600)")
    print(f"  - Public Key: {public_key}")

    return public_key


def compute_hostname(network_name, wg_ip):
    """Compute hostname as {network_name}-{3rd_octet}-{4th_octet}."""
    ip_parts = wg_ip.split(".")
    return f"{network_name}-{ip_parts[2]}-{ip_parts[3]}"


def register_peer(server, port, network_name, wg_public_key, api_password, subnet):
    """Register the device with the WireGuard server and return its assigned IP and connection details."""
    server_url = f"http://{server}:{port}/register-peer"
    print(f"ğŸ“¡ Registering device on network '{network_name}' with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={"network_name": network_name, "subnet_offset": subnet},
        headers=headers,
    )

    print(f"Status Code: {response.status_code}")
    print(f"Response Headers: {response.headers}")
    print(f"Response Text: {response.text}")

    if response.status_code != 200:
        print(f"âŒ Failed to register. Server response: {response.text}")
        sys.exit(1)

    data = response.json()
    wg_ip = data["wg_ip"]
    server_pubkey = data["wg_public_key"]
    wg_public_ip = data["wg_public_ip"]
    wg_port = data["wg_port"]

    hostname = compute_hostname(network_name, wg_ip)

    # Register the WireGuard public key separately
    register_wireguard_key(server, port, wg_ip, wg_public_key, api_password)

    return wg_ip, hostname, server_pubkey, wg_public_ip, wg_port


def register_wireguard_key(server, port, wg_ip, wg_public_key, api_password):
    """Registers the WireGuard public key for this device."""
    server_url = f"http://{server}:{port}/register-wireguard-key"
    print(f"ğŸ”‘ Registering WireGuard public key with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={"wg_ip": wg_ip, "wg_public_key": wg_public_key},
        headers=headers,
    )

    if response.status_code != 200:
        print(f"âŒ Failed to register WireGuard key. Server response: {response.text}")
        sys.exit(1)

    print(f"âœ… WireGuard key registered for {wg_ip}.")


def change_hostname(new_hostname):
    """Change the system hostname to the computed value."""
    current_hostname = run_command("hostname")
    if current_hostname != new_hostname:
        print(f"ğŸ”„ Changing hostname from {current_hostname} to {new_hostname}...")

        run_command(f"echo '{new_hostname}' | sudo tee /etc/hostname > /dev/null")

        run_command("sudo cp /etc/hosts /etc/hosts.bak")
        hosts = run_command("cat /etc/hosts").splitlines()

        updated_hosts = []
        for line in hosts:
            if "127.0.1.1" in line:
                updated_hosts.append(f"127.0.1.1 {new_hostname}")
            else:
                updated_hosts.append(line)

        run_command(
            f"echo '{chr(10).join(updated_hosts)}' | sudo tee /etc/hosts > /dev/null"
        )

        print(
            f"âœ… Hostname changed manually to {new_hostname} (will apply after restart)"
        )
    else:
        print(f"âœ… Hostname is already set to {new_hostname}")


def write_wireguard_config(
    wg_ip,
    server_pubkey,
    wg_config_dir,
    wg_public_ip,
    wg_port,
    network_name,
    force,
    wg_keepalive,
):
    """Write the WireGuard configuration file with secure permissions."""

    private_key_file = os.path.join(wg_config_dir, "private.key")
    wg_config_file = os.path.join(wg_config_dir, f"{network_name}.conf")

    if os.path.exists(wg_config_file):
        print(f"âš ï¸ WireGuard config file {wg_config_file} already exists.")
        if not force:
            print(
                "ğŸš« Aborting to prevent overwriting existing configuration. Use --force to override."
            )
            sys.exit(1)

    private_key = run_command(f"sudo cat {private_key_file}")

    # Correctly extract the first two octets for AllowedIPs
    ip_parts = wg_ip.split(".")
    if len(ip_parts) != 4:
        print(f"âŒ Error: Invalid IP format received: {wg_ip}")
        sys.exit(1)

    base_ip = f"{ip_parts[0]}.{ip_parts[1]}"
    allowed_ips = f"{base_ip}.0.0/16"

    config = f"""
[Interface]
PrivateKey = {private_key}
Address = {wg_ip}/32

[Peer]
PublicKey = {server_pubkey}
Endpoint = {wg_public_ip}:{wg_port} 
AllowedIPs = {allowed_ips}
PersistentKeepalive = {wg_keepalive}
"""

    # Write the WireGuard configuration securely
    run_command(f"echo '{config}' | sudo tee {wg_config_file} > /dev/null")
    run_command(f"sudo chmod 600 {wg_config_file}")

    print(
        f"âœ… WireGuard configuration written to {wg_config_file} (permissions set to 600)"
    )
    print(f"ğŸ”§ Allowed IPs set to {allowed_ips}")


def generate_ssh_keys(force):
    """Generate an SSH key pair if not already present."""
    ssh_dir = os.path.expanduser("~/.ssh")  # Store keys in the home directory
    os.makedirs(ssh_dir, exist_ok=True)  # Create ~/.ssh if it doesn't exist

    private_key_file = os.path.join(ssh_dir, "id_ed25519")
    public_key_file = f"{private_key_file}.pub"

    if os.path.exists(private_key_file) and os.path.exists(public_key_file):
        print("âš ï¸ SSH keys already exist.")
        if not force:
            print(
                "ğŸš« Aborting to prevent overwriting existing keys. Use --force to override."
            )
            sys.exit(1)

    print("ğŸ”‘ Generating new SSH key pair...")
    run_command(f"ssh-keygen -t ed25519 -f {private_key_file} -q -N ''")

    if not os.path.exists(public_key_file):
        print(
            f"âŒ Error: Failed to generate SSH public key at {public_key_file}",
            file=sys.stderr,
        )
        sys.exit(1)

    # Secure private key permissions
    os.chmod(private_key_file, 0o600)

    print(f"âœ… SSH key generated at {private_key_file} and {public_key_file}.")


def extract_ssh_key_params(public_key_file):
    """Extract SSH key type, size, fingerprint, comment, and expiration date, handling missing files."""

    if not os.path.exists(public_key_file):
        print(
            f"âŒ Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        return None, None, None, None, None

    try:
        # Read the public key
        with open(public_key_file, "r") as f:
            key_parts = f.read().strip().split()

        if len(key_parts) < 2:
            print(
                f"âŒ Error: Invalid SSH key format in '{public_key_file}'.",
                file=sys.stderr,
            )
            return None, None, None, None, None

        key_type = key_parts[0]  # e.g., 'ssh-ed25519', 'ssh-rsa', etc.
        key_comment = key_parts[-1] if len(key_parts) > 2 else None

        # Get the fingerprint and key size
        key_info = run_command(f"ssh-keygen -lf {public_key_file}")
        if not key_info:
            print(
                f"âŒ Error: Failed to extract key details from '{public_key_file}'.",
                file=sys.stderr,
            )
            return key_type, None, key_comment, None, None

        key_info_parts = key_info.split()
        if len(key_info_parts) < 2:
            return key_type, None, key_comment, None, None

        fingerprint = key_info_parts[1]

        # Ensure key_size is an integer
        try:
            key_size = int(key_info_parts[0])  # Convert from string to integer
        except ValueError:
            print(
                f"âš ï¸ Warning: Failed to parse key size '{key_info_parts[0]}'. Defaulting to None."
            )
            key_size = None

        # Extract expiration date if present in comment
        expires_at = None
        if key_comment:
            try:
                # Example: "user@host expires:2026-01-01"
                if "expires:" in key_comment:
                    expires_str = key_comment.split("expires:")[-1].strip()
                    expires_at = datetime.datetime.strptime(
                        expires_str, "%Y-%m-%d"
                    ).isoformat()
            except ValueError:
                print(
                    f"âš ï¸ Warning: Could not parse expiration date from comment '{key_comment}'."
                )
                expires_at = None

        return key_type, key_size, key_comment, fingerprint, expires_at

    except Exception as e:
        print(
            f"âŒ Exception while processing '{public_key_file}': {e}", file=sys.stderr
        )
        return None, None, None, None, None


def exchange_ssh_keys(server, port, wg_ip, api_password):
    """Registers an SSH public key for this device using its WireGuard IP."""

    ssh_dir = os.path.expanduser("~/.ssh")
    public_key_file = os.path.join(ssh_dir, "id_ed25519.pub")
    authorized_keys_file = os.path.join(ssh_dir, "authorized_keys")

    if not os.path.exists(public_key_file):
        print(
            f"âŒ Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        sys.exit(1)

    # Extract SSH key details
    username = os.getenv("USER") or run_command("whoami")
    uid = os.getuid()
    key_type, key_size, key_comment, fingerprint, expires_at = extract_ssh_key_params(
        public_key_file
    )

    if not key_type or not fingerprint:
        print(
            f"âŒ Failed to extract SSH key details from {public_key_file}",
            file=sys.stderr,
        )
        sys.exit(1)

    # Prepare the payload ensuring correct types
    payload = {
        "wg_ip": wg_ip,
        "username": username,
        "uid": uid,
        "ssh_public_key": open(public_key_file).read().strip(),
        "key_type": key_type,
        "key_size": key_size if key_size else None,
        "key_comment": key_comment,
        "fingerprint": fingerprint,
        "expires_at": (expires_at if expires_at else None),
    }

    server_url = f"http://{server}:{port}/exchange-ssh-keys"
    print(f"ğŸ”‘ Registering SSH public key with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(server_url, json=payload, headers=headers)

    if response.status_code != 200:
        print(f"âŒ Failed to register SSH key. Server response: {response.text}")
        sys.exit(1)

    print(f"âœ… SSH key registered successfully for peer with WireGuard IP {wg_ip}.")

    # Append the returned SSH public key to authorized_keys
    server_public_key = response.json().get("ssh_public_key")

    if not server_public_key:
        print(f"âŒ No SSH public key returned from server.", file=sys.stderr)
        sys.exit(1)

    with open(authorized_keys_file, "a") as auth_keys:
        auth_keys.write(server_public_key + "\n")

    print(f"âœ… Server public key added to {authorized_keys_file}.")

    print(f"âœ… SSH key registered successfully for peer with WireGuard IP {wg_ip}.")


def main():
    """Main execution flow."""
    args = parse_args()

    print("ğŸš€ Starting device configuration...")

    api_password = get_api_password()

    wg_public_key = generate_wireguard_keys(args.wg_config_dir, args.force)

    # Retrieve correct WireGuard server information
    wg_ip, hostname, server_pubkey, wg_public_ip, wg_port = register_peer(
        args.server, args.port, args.network, wg_public_key, api_password, args.subnet
    )

    write_wireguard_config(
        wg_ip,
        server_pubkey,
        args.wg_config_dir,
        wg_public_ip,
        wg_port,
        args.network,
        args.force,
        args.wg_keepalive,
    )

    change_hostname(hostname)

    generate_ssh_keys(args.force)

    exchange_ssh_keys(args.server, args.port, wg_ip, api_password)

    print("Starting WireGuard and SSH...")

    try:
        enable_wireguard(args.network)
        enable_ssh(passwords=args.enable_ssh_passwords)
        print("Success starting wireguard and ssh.")
    except:
        print("Failure starting wireguard or ssh.")

    print(
        "âœ… Configuration complete. Hostname has been updated, and WireGuard is set up."
    )

    print("Reboot now and check connectivity to the server.")


if __name__ == "__main__":
    main()
