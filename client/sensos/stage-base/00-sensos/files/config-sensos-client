#!/usr/bin/env python3
import os
import sys
import stat
import argparse
import requests
import datetime
import subprocess
import base64
import json
import shutil

WG_DIR = "/etc/wireguard"

# Default Configuration
DEFAULT_SERVER = "localhost"
DEFAULT_PORT = "8000"
DEFAULT_NETWORK_NAME = "sensos"
DEFAULT_KEEPALIVE = "0"

API_PASSWORD_FILE = os.path.expanduser("~/.sensos_api_password")
REGISTRY_CONFIG_FILE = os.path.expanduser("~/.sensos_registry_config.json")

def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Configure the Sensos WireGuard client."
    )
    parser.add_argument(
        "--server",
        default=DEFAULT_SERVER,
        help="API server hostname or IP (default: localhost)",
    )
    parser.add_argument(
        "--port",
        default=DEFAULT_PORT,
        help="Server port (default: 8000)",
    )
    parser.add_argument(
        "--network", default=DEFAULT_NETWORK_NAME, help="Network name (default: sensos)"
    )
    parser.add_argument(
        "--wg-keepalive",
        default=DEFAULT_KEEPALIVE,
        help="WireGuard persistent keepalive interval (default: 0 seconds)",
    )
    parser.add_argument(
        "--subnet",
        type=int,
        default=1,
        help="Subnet offset for WireGuard IP assignment (default: 1, i.e., x.x.1.1)",
    )
    parser.add_argument(
        "--wg-server-ip",
        default=None,
        help="Override WireGuard endpoint IP (default: use server-assigned IP)",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force overwrite of existing files and settings",
    )
    parser.add_argument(
        "--enable-ssh-passwords",
        action="store_true",
        help="Enable SSH password authentication (default: disabled)",
    )
    parser.add_argument(
        "--no-connectivity-checks",
        action="store_true",
        help="Indicate device has no networking; skip connectivity check service",
    )
    return parser.parse_args()


def run_command(cmd):
    """Runs a shell command and returns its output."""
    return subprocess.run(
        cmd, shell=True, check=True, capture_output=True, text=True
    ).stdout.strip()


def enable_wireguard(netname: str):
    service_name = f"wg-quick@{netname}.service"
    run_command(f"sudo systemctl enable {service_name}")
    run_command(f"sudo systemctl start {service_name}")
    print(f"✅ WireGuard service {service_name} enabled and started.")


def enable_ssh(passwords: bool = False):
    """Enable SSH and configure password authentication based on the `passwords` flag."""
    sshd_config = "/etc/ssh/sshd_config"
    backup_config = "/etc/ssh/sshd_config.bak"

    # Backup before modifying
    run_command(f"sudo cp -a {sshd_config} {backup_config}")

    # Set password authentication based on flag
    password_setting = "yes" if passwords else "no"
    run_command(
        f"sudo sed -i 's/^#?PasswordAuthentication .*/PasswordAuthentication {password_setting}/' {sshd_config}"
    )

    print(f"✅ SSH passwords are {'enabled' if passwords else 'disabled'}.")

    # Ensure public key authentication is enabled
    run_command(
        f"sudo sed -i 's/^#?PubkeyAuthentication .*/PubkeyAuthentication yes/' {sshd_config}"
    )

    # Enable and start SSH service
    run_command("sudo systemctl enable ssh")
    run_command("sudo systemctl start ssh")

    print("✅ SSH service enabled and started.")
    print("🔄 A reboot is required for changes to fully take effect.")


def get_basic_auth(api_password):
    """Encode API password in Basic Auth format."""
    auth_str = f":{api_password}"  # Username is ignored, so empty username
    return base64.b64encode(auth_str.encode()).decode()


def validate_api_password(server, port, api_password):
    """Test the API password by sending a GET request to a /validate endpoint."""
    url = f"http://{server}:{port}/"
    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    try:
        response = requests.get(url, headers=headers, timeout=5)
        if response.status_code == 200:
            return True
        else:
            print(
                f"❌ Server returned status code {response.status_code}.",
                file=sys.stderr,
            )
            return False
    except Exception as e:
        print(f"❌ Error testing API password: {e}", file=sys.stderr)
        return False


def get_api_password(server, port):
    """Retrieve or prompt for API password, testing it with the server.
    Allows up to 3 attempts.
    """
    tries = 3
    for attempt in range(tries):
        if os.path.exists(API_PASSWORD_FILE):
            with open(API_PASSWORD_FILE, "r") as f:
                stored_password = f.read().strip()
            print("Testing stored API password...")
            if validate_api_password(server, port, stored_password):
                print("✅ API password from file is valid.")
                return stored_password
            else:
                print("⚠️ Stored API password is invalid.", file=sys.stderr)
        api_password = input("🔑 Enter API password: ").strip()
        if validate_api_password(server, port, api_password):
            if api_password is None or api_password == "":
                print("❌ Error: API password is empty. Not saving.", file=sys.stderr)
                continue
            with open(API_PASSWORD_FILE, "w") as f:
                f.write(api_password)
            os.chmod(API_PASSWORD_FILE, stat.S_IRUSR | stat.S_IWUSR)
            print(f"✅ API password saved securely in {API_PASSWORD_FILE}.")
            return api_password
        else:
            print("❌ API password is invalid, please try again.", file=sys.stderr)
    print(
        "🚫 Failed to provide a valid API password after 3 attempts.", file=sys.stderr
    )
    return None


def generate_wireguard_keys(force):
    """Generate WireGuard key pair if not already present. Returns public key."""
    if not os.path.isdir(WG_DIR):
        print(
            f"❌ Error: Configuration directory '{WG_DIR}' does not exist.",
            file=sys.stderr,
        )
        return None

    private_key_file = os.path.join(WG_DIR, "private.key")
    public_key_file = os.path.join(WG_DIR, "public.key")

    if os.path.exists(private_key_file) or os.path.exists(public_key_file):
        print("⚠️ WireGuard keys already exist.", file=sys.stderr)
        if not force:
            print(
                "🚫 Aborting to prevent overwriting existing keys. Use --force to override.",
                file=sys.stderr,
            )
            return None

    print("🔑 Generating new WireGuard key pair...")
    private_key = run_command("wg genkey")
    public_key = run_command(f"echo {private_key} | wg pubkey")

    if not private_key or not public_key:
        print("❌ Error: Failed to generate valid WireGuard keys.", file=sys.stderr)
        return None

    run_command(f"echo '{private_key}' | sudo tee {private_key_file} > /dev/null")
    run_command(f"sudo chmod 600 {private_key_file}")
    run_command(f"echo '{public_key}' | sudo tee {public_key_file} > /dev/null")

    print(f"  - Private Key stored in: {private_key_file} (permissions set to 600)")
    print(f"  - Public Key: {public_key}")

    return public_key


def compute_hostname(network_name, wg_ip):
    """Compute hostname as {network_name}-{3rd_octet}-{4th_octet}."""
    ip_parts = wg_ip.split(".")
    if len(ip_parts) != 4:
        print(f"❌ Error: Invalid IP format '{wg_ip}'.", file=sys.stderr)
        return None
    return f"{network_name}-{ip_parts[2]}-{ip_parts[3]}"


def register_peer(server, port, network_name, wg_public_key, api_password, subnet):
    """Register the device with the WireGuard server and return its assigned IP and connection details."""
    if wg_public_key is None:
        print(
            "❌ Error: Invalid WireGuard public key. Skipping peer registration.",
            file=sys.stderr,
        )
        return None, None, None, None, None

    server_url = f"http://{server}:{port}/register-peer"
    print(f"📡 Registering device on network '{network_name}' with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={"network_name": network_name, "subnet_offset": subnet},
        headers=headers,
    )

    print(f"Status Code: {response.status_code}")
    print(f"Response Headers: {response.headers}")
    print(f"Response Text: {response.text}")

    if response.status_code != 200:
        print(
            f"❌ Failed to register. Server response: {response.text}", file=sys.stderr
        )
        return None, None, None, None, None

    data = response.json()
    wg_ip = data.get("wg_ip")
    server_pubkey = data.get("wg_public_key")
    wg_public_ip = data.get("wg_public_ip")
    wg_port = data.get("wg_port")

    if not all([wg_ip, server_pubkey, wg_public_ip, wg_port]):
        print(
            "❌ Error: Incomplete data received from peer registration.",
            file=sys.stderr,
        )
        return None, None, None, None, None

    hostname = compute_hostname(network_name, wg_ip)
    if hostname is None:
        print(
            "❌ Error: Could not compute hostname due to invalid IP.", file=sys.stderr
        )
        return None, None, None, None, None

    register_wireguard_key(server, port, wg_ip, wg_public_key, api_password)
    return wg_ip, hostname, server_pubkey, wg_public_ip, wg_port


def register_wireguard_key(server, port, wg_ip, wg_public_key, api_password):
    """Registers the WireGuard public key for this device."""
    if wg_ip is None or wg_public_key is None:
        print(
            "❌ Error: Missing WireGuard IP or public key for registration.",
            file=sys.stderr,
        )
        return

    server_url = f"http://{server}:{port}/register-wireguard-key"
    print(f"🔑 Registering WireGuard public key with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={"wg_ip": wg_ip, "wg_public_key": wg_public_key},
        headers=headers,
    )

    if response.status_code != 200:
        print(
            f"❌ Failed to register WireGuard key. Server response: {response.text}",
            file=sys.stderr,
        )
    else:
        print(f"✅ WireGuard key registered for {wg_ip}.")


def change_hostname(new_hostname):
    """Change the system hostname to the computed value."""
    if new_hostname is None:
        print(
            "❌ Error: New hostname is invalid. Skipping hostname change.",
            file=sys.stderr,
        )
        return

    current_hostname = run_command("hostname")
    if current_hostname != new_hostname:
        print(f"🔄 Changing hostname from {current_hostname} to {new_hostname}...")
        run_command(f"echo '{new_hostname}' | sudo tee /etc/hostname > /dev/null")
        run_command("sudo cp /etc/hosts /etc/hosts.bak")
        hosts = run_command("cat /etc/hosts").splitlines()
        updated_hosts = []
        for line in hosts:
            if "127.0.1.1" in line:
                updated_hosts.append(f"127.0.1.1 {new_hostname}")
            else:
                updated_hosts.append(line)
        run_command(
            f"echo '{chr(10).join(updated_hosts)}' | sudo tee /etc/hosts > /dev/null"
        )
        print(
            f"✅ Hostname changed manually to {new_hostname} (will apply after restart)"
        )
    else:
        print(f"✅ Hostname is already set to {new_hostname}")


def write_wireguard_config(
    wg_ip,
    server_pubkey,
    wg_public_ip,
    wg_port,
    network_name,
    force,
    wg_keepalive,
):
    """Write the WireGuard configuration file with secure permissions."""
    if not all([wg_ip, server_pubkey, wg_public_ip, wg_port]):
        print(
            "❌ Error: Incomplete WireGuard data. Configuration not written.",
            file=sys.stderr,
        )
        return

    private_key_file = os.path.join(WG_DIR, "private.key")
    wg_config_file = os.path.join(WG_DIR, f"{network_name}.conf")
    if os.path.exists(wg_config_file):
        print(
            f"⚠️ WireGuard config file {wg_config_file} already exists.", file=sys.stderr
        )
        if not force:
            print(
                "🚫 Aborting to prevent overwriting existing configuration. Use --force to override.",
                file=sys.stderr,
            )
            return

    private_key = run_command(f"sudo cat {private_key_file}")
    if not private_key:
        print(
            "❌ Error: Private key is missing. Cannot write configuration.",
            file=sys.stderr,
        )
        return

    ip_parts = wg_ip.split(".")
    if len(ip_parts) != 4:
        print(f"❌ Error: Invalid IP format received: {wg_ip}", file=sys.stderr)
        return

    base_ip = f"{ip_parts[0]}.{ip_parts[1]}"
    allowed_ips = f"{base_ip}.0.0/16"

    config = f"""
[Interface]
PrivateKey = {private_key}
Address = {wg_ip}/32

[Peer]
PublicKey = {server_pubkey}
Endpoint = {wg_public_ip}:{wg_port} 
AllowedIPs = {allowed_ips}
PersistentKeepalive = {wg_keepalive}
"""

    run_command(f"echo '{config}' | sudo tee {wg_config_file} > /dev/null")
    run_command(f"sudo chmod 600 {wg_config_file}")
    print(
        f"✅ WireGuard configuration written to {wg_config_file} (permissions set to 600)"
    )
    print(f"🔧 Allowed IPs set to {allowed_ips}")


def generate_ssh_keys(force):
    """Generate an SSH key pair if not already present."""
    ssh_dir = os.path.expanduser("~/.ssh")
    os.makedirs(ssh_dir, exist_ok=True)
    private_key_file = os.path.join(ssh_dir, "id_ed25519")
    public_key_file = f"{private_key_file}.pub"
    if os.path.exists(private_key_file) and os.path.exists(public_key_file):
        print("⚠️ SSH keys already exist.", file=sys.stderr)
        if not force:
            print(
                "🚫 Aborting to prevent overwriting existing keys. Use --force to override.",
                file=sys.stderr,
            )
            return
    print("🔑 Generating new SSH key pair...")
    run_command(f"ssh-keygen -t ed25519 -f {private_key_file} -q -N ''")
    if not os.path.exists(public_key_file):
        print(
            f"❌ Error: Failed to generate SSH public key at {public_key_file}",
            file=sys.stderr,
        )
        return
    os.chmod(private_key_file, 0o600)
    print(f"✅ SSH key generated at {private_key_file} and {public_key_file}.")


def extract_ssh_key_params(public_key_file):
    """Extract SSH key type, size, fingerprint, comment, and expiration date, handling missing files."""
    if not os.path.exists(public_key_file):
        print(
            f"❌ Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        return None, None, None, None, None
    try:
        with open(public_key_file, "r") as f:
            key_parts = f.read().strip().split()
        if len(key_parts) < 2:
            print(
                f"❌ Error: Invalid SSH key format in '{public_key_file}'.",
                file=sys.stderr,
            )
            return None, None, None, None, None
        key_type = key_parts[0]
        key_comment = key_parts[-1] if len(key_parts) > 2 else None
        key_info = run_command(f"ssh-keygen -lf {public_key_file}")
        if not key_info:
            print(
                f"❌ Error: Failed to extract key details from '{public_key_file}'.",
                file=sys.stderr,
            )
            return key_type, None, key_comment, None, None
        key_info_parts = key_info.split()
        if len(key_info_parts) < 2:
            return key_type, None, key_comment, None, None
        fingerprint = key_info_parts[1]
        try:
            key_size = int(key_info_parts[0])
        except ValueError:
            print(
                f"⚠️ Warning: Failed to parse key size '{key_info_parts[0]}'. Defaulting to None.",
                file=sys.stderr,
            )
            key_size = None
        expires_at = None
        if key_comment:
            try:
                if "expires:" in key_comment:
                    expires_str = key_comment.split("expires:")[-1].strip()
                    expires_at = datetime.datetime.strptime(
                        expires_str, "%Y-%m-%d"
                    ).isoformat()
            except ValueError:
                print(
                    f"⚠️ Warning: Could not parse expiration date from comment '{key_comment}'.",
                    file=sys.stderr,
                )
                expires_at = None
        return key_type, key_size, key_comment, fingerprint, expires_at
    except Exception as e:
        print(
            f"❌ Exception while processing '{public_key_file}': {e}", file=sys.stderr
        )
        return None, None, None, None, None


def exchange_ssh_keys(server, port, wg_ip, api_password):
    """Registers an SSH public key for this device using its WireGuard IP."""
    ssh_dir = os.path.expanduser("~/.ssh")
    public_key_file = os.path.join(ssh_dir, "id_ed25519.pub")
    authorized_keys_file = os.path.join(ssh_dir, "authorized_keys")
    if not os.path.exists(public_key_file):
        print(
            f"❌ Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        return
    username = os.getenv("USER") or run_command("whoami")
    uid = os.getuid()
    key_type, key_size, key_comment, fingerprint, expires_at = extract_ssh_key_params(
        public_key_file
    )
    if not key_type or not fingerprint:
        print(
            f"❌ Failed to extract SSH key details from {public_key_file}",
            file=sys.stderr,
        )
        return
    payload = {
        "wg_ip": wg_ip,
        "username": username,
        "uid": uid,
        "ssh_public_key": open(public_key_file).read().strip(),
        "key_type": key_type,
        "key_size": key_size if key_size else None,
        "key_comment": key_comment,
        "fingerprint": fingerprint,
        "expires_at": expires_at if expires_at else None,
    }
    if not all([wg_ip, payload["ssh_public_key"], key_type, fingerprint]):
        print("❌ Error: Incomplete SSH key data. Aborting exchange.", file=sys.stderr)
        return
    server_url = f"http://{server}:{port}/exchange-ssh-keys"
    print(f"🔑 Registering SSH public key with {server_url}...")
    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(server_url, json=payload, headers=headers)
    if response.status_code != 200:
        print(
            f"❌ Failed to register SSH key. Server response: {response.text}",
            file=sys.stderr,
        )
        return
    print(f"✅ SSH key registered successfully for peer with WireGuard IP {wg_ip}.")
    server_public_key = response.json().get("ssh_public_key")
    if not server_public_key:
        print("❌ No SSH public key returned from server.", file=sys.stderr)
        return
    with open(authorized_keys_file, "a") as auth_keys:
        auth_keys.write(server_public_key + "\n")
    print(f"✅ Server public key added to {authorized_keys_file}.")
    print(f"✅ SSH key registered successfully for peer with WireGuard IP {wg_ip}.")


def read_file(filepath):
    """Reads a file and returns its contents as a string, or None if an error occurs."""
    try:
        with open(filepath, "r") as f:
            return f.read().strip()
    except Exception as e:
        print(f"❌ Error reading file {filepath}: {e}", file=sys.stderr)
        return None


def sudo_read_file(filepath):
    """Helper to read a file using sudo (for WireGuard files not world-readable)."""
    try:
        content = run_command(f"sudo cat {filepath}")
        return content.strip()
    except Exception as e:
        print(f"❌ Error reading {filepath} with sudo: {e}", file=sys.stderr)
        return None


def parse_local_config(config_file):
    """
    Simple parser for a WireGuard config file using sudo.
    Returns a dict with keys:
      - wg_ip: from the [Interface] Address line (e.g., "10.0.0.5" from "Address = 10.0.0.5/32")
      - server_pubkey: from the [Peer] PublicKey line
    """
    config = {}
    content = sudo_read_file(config_file)
    if not content:
        return config
    current_section = None
    for line in content.splitlines():
        line = line.strip()
        if line.startswith("[") and line.endswith("]"):
            current_section = line[1:-1].strip()
        elif "=" in line and current_section:
            key, value = [x.strip() for x in line.split("=", 1)]
            if current_section.lower() == "interface" and key.lower() == "address":
                config["wg_ip"] = value.split("/")[0]
            elif current_section.lower() == "peer" and key.lower() == "publickey":
                config["server_pubkey"] = value
    return config

def configure_wireguard(args, api_password):
    """
    Check whether the local WireGuard configuration is valid...
    If missing or mismatched, perform full WireGuard reconfiguration.
    Returns the client’s WireGuard IP.
    """
    config_file = os.path.join(WG_DIR, f"{args.network}.conf")
    reconfigure_wg = True

    if os.path.exists(config_file):
        print(f"Found WireGuard config at {config_file}.")
        local_config = parse_local_config(config_file)
        if "wg_ip" in local_config:
            local_wg_ip = local_config["wg_ip"]
            print(f"Local WireGuard IP: {local_wg_ip}. Querying /get-peer-info...")
            url = f"http://{args.server}:{args.port}/get-peer-info?ip_address={local_wg_ip}"
            headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
            try:
                resp = requests.get(url, headers=headers, timeout=5)
                if resp.status_code == 200:
                    peer_info = resp.json()
                    if peer_info.get("exists"):
                        local_server_pubkey = local_config.get("server_pubkey")
                        local_peer_pubkey = read_file(os.path.join(WG_DIR, "public.key"))
                        if local_server_pubkey == peer_info.get("network_wg_public_key") and local_peer_pubkey == peer_info.get("peer_wg_public_key"):
                            print("Local WireGuard configuration matches API records.")
                            if not args.force:
                                choice = input("Reconfigure WireGuard? (y/N): ").strip().lower()
                                reconfigure_wg = choice == "y"
                            else:
                                reconfigure_wg = True
                        else:
                            print("❌ Mismatch in WireGuard keys detected. Reconfiguration required.", file=sys.stderr)
                    else:
                        print("❌ Peer not registered in API. Full WireGuard configuration needed.", file=sys.stderr)
                else:
                    print(f"❌ /get-peer-info returned {resp.status_code}; proceeding with reconfiguration.", file=sys.stderr)
            except Exception as e:
                print("❌ Error accessing /get-peer-info:", e, file=sys.stderr)
        else:
            print("❌ Local config does not contain a valid WireGuard IP.", file=sys.stderr)
    else:
        print("❌ No local WireGuard configuration file found.", file=sys.stderr)

    if reconfigure_wg:
        print("Reconfiguring WireGuard...")
        wg_public_key = generate_wireguard_keys(args.force)
        if wg_public_key is None:
            print("❌ WireGuard key generation failed. Skipping WireGuard configuration.", file=sys.stderr)
            return None
        
        wg_ip, hostname, server_pubkey, wg_public_ip, wg_port = register_peer(
            args.server, args.port, args.network, wg_public_key, api_password, args.subnet
        )
        if not wg_ip:
            print("❌ Peer registration failed. Skipping WireGuard configuration.", file=sys.stderr)
            return None

        # If --wg-server-ip is provided, override wg_public_ip
        if args.wg_server_ip:
            print(f"⚠️ Overriding WireGuard endpoint IP: {wg_public_ip} → {args.wg_server_ip}")
            wg_public_ip = args.wg_server_ip

        write_wireguard_config(
            wg_ip, server_pubkey, wg_public_ip, wg_port, args.network, args.force, args.wg_keepalive
        )

        change_hostname(hostname)
        return wg_ip
    else:
        print("Keeping existing WireGuard configuration.")
        local_config = parse_local_config(config_file)
        return local_config.get("wg_ip", args.server)


def configure_ssh(args, api_password):
    """
    Check if SSH keys exist and whether the registered SSH public key (via /get-peer-info)
    matches the local SSH public key. If missing or mismatched, or if the user chooses to
    reconfigure (unless --force), generate new SSH keys and exchange them with the server.
    """
    ssh_private = os.path.expanduser("~/.ssh/id_ed25519")
    ssh_public = os.path.expanduser("~/.ssh/id_ed25519.pub")
    reconfigure_ssh = True
    if os.path.exists(ssh_private) and os.path.exists(ssh_public):
        local_ssh_pubkey = read_file(ssh_public)
        config_file = os.path.join(WG_DIR, f"{args.network}.conf")
        wg_config_content = sudo_read_file(config_file)
        if wg_config_content:
            local_config = parse_local_config(config_file)
            if "wg_ip" in local_config:
                local_wg_ip = local_config["wg_ip"]
                print(
                    f"Querying /get-peer-info for SSH keys using WG IP {local_wg_ip}..."
                )
                url = f"http://{args.server}:{args.port}/get-peer-info?ip_address={local_wg_ip}"
                headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
                try:
                    resp = requests.get(url, headers=headers, timeout=5)
                    if resp.status_code == 200:
                        peer_info = resp.json()
                        if peer_info.get("ssh_public_key") == local_ssh_pubkey:
                            print("SSH key configuration matches API records.")
                            if not args.force:
                                choice = (
                                    input("Reconfigure SSH keys? (y/N): ")
                                    .strip()
                                    .lower()
                                )
                                reconfigure_ssh = choice == "y"
                            else:
                                reconfigure_ssh = True
                        else:
                            print(
                                "❌ Local SSH key does not match API. Reconfiguration required.",
                                file=sys.stderr,
                            )
                    else:
                        print(
                            f"❌ /get-peer-info returned {resp.status_code} for SSH; reconfiguring SSH.",
                            file=sys.stderr,
                        )
                except Exception as e:
                    print(
                        "❌ Error accessing /get-peer-info for SSH:", e, file=sys.stderr
                    )
            else:
                print(
                    "❌ No WG IP found in local config; cannot verify SSH keys.",
                    file=sys.stderr,
                )
        else:
            print(
                "❌ No local WireGuard config available (cannot read with sudo); skipping SSH key exchange.",
                file=sys.stderr,
            )
    else:
        print("SSH keys not found; new keys will be generated.")

    if reconfigure_ssh:
        print("Reconfiguring SSH keys...")
        generate_ssh_keys(args.force)
        config_file = os.path.join(WG_DIR, f"{args.network}.conf")
        wg_config_content = sudo_read_file(config_file)
        if wg_config_content:
            local_config = parse_local_config(config_file)
            if "wg_ip" in local_config:
                wg_ip = local_config["wg_ip"]
                exchange_ssh_keys(args.server, args.port, wg_ip, api_password)
            else:
                print(
                    "❌ No WG IP available in config; cannot exchange SSH keys.",
                    file=sys.stderr,
                )
        else:
            print(
                "❌ No local WG config available; skipping SSH key exchange.",
                file=sys.stderr,
            )
    else:
        print("Keeping existing SSH key configuration.")


def validate_registry_password(registry_info, registry_password):
    url = f"https://{registry_info['registry_ip']}:{registry_info['registry_port']}/v2/"
    auth = (registry_info["registry_user"], registry_password)
    try:
        response = requests.get(url, auth=auth, timeout=5, verify=False)
        return response.status_code == 200
    except requests.exceptions.RequestException as e:
        print(f"❌ Debug: Error during request: {e}", file=sys.stderr)
        return False


def save_registry_config(registry_info, registry_password):
    if not registry_info or not registry_password:
        print(
            "❌ Error: Incomplete registry configuration data. Not saving.",
            file=sys.stderr,
        )
        return
    required_keys = ["registry_ip", "registry_port", "registry_user"]
    if not all(key in registry_info for key in required_keys):
        print(
            "❌ Error: Registry information is incomplete. Not saving.", file=sys.stderr
        )
        return
    config = {
        "registry_ip": registry_info["registry_ip"],
        "registry_port": registry_info["registry_port"],
        "registry_user": registry_info["registry_user"],
        "registry_password": registry_password,
    }
    with open(REGISTRY_CONFIG_FILE, "w") as f:
        json.dump(config, f)
    os.chmod(REGISTRY_CONFIG_FILE, 0o600)
    print(f"✅ Registry configuration saved to {REGISTRY_CONFIG_FILE}.")


def get_registry_password_from_info(registry_info):
    tries = 3
    for attempt in range(tries):
        if os.path.exists(REGISTRY_CONFIG_FILE):
            with open(REGISTRY_CONFIG_FILE, "r") as f:
                stored_config = json.load(f)
                stored_password = stored_config.get("registry_password")
                if stored_password:
                    return stored_password
            print(
                "⚠️ Password not found in config file or file malformed.",
                file=sys.stderr,
            )

        # Prompt if password isn't stored yet or config missing
        registry_password = input("🔑 Enter registry password: ").strip()
        if not registry_password:
            print("❌ Error: Empty registry password provided.", file=sys.stderr)
            continue
        if validate_registry_password(registry_info, registry_password):
            save_registry_config(registry_info, registry_password)
            print(f"✅ Registry password saved to {REGISTRY_CONFIG_FILE}.")
            return registry_password
    print(
        "❌ Failed to obtain a valid registry password after 3 attempts.",
        file=sys.stderr,
    )
    return None


def compute_api_server_wg_ip(client_wg_ip):
    """Compute the API server’s WireGuard IP (x.x.0.1) from the client’s WireGuard IP."""
    parts = client_wg_ip.split(".")
    if len(parts) != 4:
        print(
            f"❌ Error: Invalid client WireGuard IP format: {client_wg_ip}",
            file=sys.stderr,
        )
        return None
    # Assumes the network is structured such that the server is always at x.x.0.1.
    return f"{parts[0]}.{parts[1]}.0.1"


def write_client_settings(args, server_wg_ip):
    """Write client settings to /etc/sensos/settings.conf after validating the data."""
    if not all([server_wg_ip, args.port, args.network]):
        print(
            "❌ Error: Incomplete client settings. Not writing settings file.",
            file=sys.stderr,
        )
        return
    settings_file = "/etc/sensos/settings.conf"
    settings_dir = os.path.dirname(settings_file)
    subprocess.run(["sudo", "mkdir", "-p", settings_dir], check=True)
    content = (
        f"SERVER_IP={server_wg_ip}\nSERVER_PORT=8000\nNETWORK_NAME={args.network}\n"
    )
    subprocess.run(["sudo", "tee", settings_file], input=content, text=True, check=True)
    subprocess.run(["sudo", "chmod", "644", settings_file], check=True)
    print(f"✅ Client settings written to {settings_file}")


def enable_service(service_name, start=False):
    """Enable and optionally start the specified systemd service using sudo."""
    if shutil.which("systemctl") is None:
        print(
            f"❌ Error: systemctl command not found. Skipping enabling service {service_name}.",
            file=sys.stderr,
        )
        return
    try:
        subprocess.run(["sudo", "systemctl", "enable", service_name], check=True)
        if start:
            subprocess.run(["sudo", "systemctl", "start", service_name], check=True)
            print(f"✅ Service {service_name} enabled and started.")
        else:
            print(f"✅ Service {service_name} enabled.")
    except subprocess.CalledProcessError as e:
        print(f"❌ Error enabling service {service_name}: {e}", file=sys.stderr)


def main():
    args = parse_args()
    print("🚀 Starting device configuration...")
    api_password = get_api_password(args.server, args.port)
    if not api_password:
        print(
            "❌ Critical error: API password not obtained. Aborting configuration.",
            file=sys.stderr,
        )
        return
    # Get the client’s WireGuard IP (assigned during peer registration or from the local config)
    client_wg_ip = configure_wireguard(args, api_password)
    if not client_wg_ip:
        print("❌ WireGuard configuration failed. Aborting.", file=sys.stderr)
        return

    # Compute the API server’s WireGuard IP as x.x.0.1 based on the client’s WireGuard IP.
    server_wg_ip = compute_api_server_wg_ip(client_wg_ip)
    if not server_wg_ip:
        print(
            "❌ Failed to compute API server WireGuard IP. Aborting.", file=sys.stderr
        )
        return

    configure_ssh(args, api_password)
    print("Starting WireGuard and SSH services...")
    try:
        enable_wireguard(args.network)
        enable_ssh(passwords=args.enable_ssh_passwords)
        print("✅ Services started successfully.")
    except Exception as e:
        print("❌ Error starting services:", e, file=sys.stderr)
    write_client_settings(args, server_wg_ip)
    if not args.no_connectivity_checks:
        enable_service("monitor-connectivity.service")
    else:
        print(
            "ℹ️ No-connectivity-checks mode active. Skipping connectivity check service enablement."
        )
    print("✅ Configuration complete. Reboot now and check connectivity.")


if __name__ == "__main__":
    main()
