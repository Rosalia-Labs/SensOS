#!/usr/bin/env python3
import os
import sys
import pwd
import argparse
import requests
import datetime
import subprocess
import configparser
import base64
import json
import shutil
import socket
import psutil
import time

sys.path.insert(0, "/sensos/lib")
from utils import *

WG_DIR = "/etc/wireguard"
SENSOS_ADMIN_HOME = "/home/sensos-admin"
SENSOS_NET_CONF = "/sensos/etc/network.conf"


def parse_args():
    script_name = os.path.basename(sys.argv[0])
    if script_name.endswith(".py"):
        script_name = script_name[:-3]
    elif "." in script_name:
        script_name = script_name.split(".")[0]
    script_name = script_name.replace("-", "_")

    arg_defs = [
        (
            ["--config-server"],
            {
                "help": "Configuration server hostname or IP (default: localhost)",
                "dest": "config_server",
            },
        ),
        (
            ["--port"],
            {
                "help": "Server port (default: 8765)",
                "dest": "port",
                "type": int,
                "default": 8765,
            },
        ),
        (
            ["--network"],
            {
                "help": "Network name (default: sensos)",
                "dest": "network",
                "default": "sensos",
            },
        ),
        (
            ["--subnet"],
            {
                "help": "Subnet offset for WireGuard IP assignment (default: 1, i.e., x.x.1.1)",
                "dest": "subnet",
                "type": int,
                "default": 1,
            },
        ),
        (
            ["--wg-endpoint"],
            {
                "help": "Override WireGuard endpoint IP (default: use server-assigned IP)",
                "dest": "wg_endpoint",
            },
        ),
        (
            ["--wg-keepalive"],
            {
                "help": "WireGuard persistent keepalive interval (default: disabled)",
                "dest": "wg_keepalive",
                "type": int,
                "default": 0,
            },
        ),
        (
            ["--enable-ssh-passwords"],
            {
                "action": "store_true",
                "help": "Enable SSH password authentication (default: disabled)",
                "dest": "enable_ssh_passwords",
            },
        ),
        (
            ["--ssh-tunnel-port"],
            {
                "help": "SSH port for clients to use when connecting to the server (default: 2345)",
                "dest": "ssh_tunnel_port",
                "type": int,
                "default": 2345,
            },
        ),
        (
            ["--ssh-tunnel-ip"],
            {
                "help": "Server hostname or IP for SSH access (default: same as WireGuard endpoint/server)",
                "dest": "ssh_tunnel_ip",
            },
        ),
        (
            ["--connectivity-mode"],
            {
                "help": "Network interface behavior: always, ondemand, offline",
                "choices": ["always", "ondemand", "offline"],
                "dest": "connectivity_mode",
                "default": "always",
            },
        ),
        (
            ["--bandwidth-policy"],
            {
                "help": "Bandwidth policy: unrestricted, restricted",
                "choices": ["unrestricted", "restricted"],
                "dest": "bandwidth_policy",
                "default": "unrestricted",
            },
        ),
        (
            ["--no-connectivity-checks"],
            {
                "action": "store_true",
                "help": "Skip connectivity check service",
                "dest": "no_connectivity_checks",
            },
        ),
        (
            ["--note"],
            {
                "help": "Optional note or description to register with the device (default: empty)",
                "dest": "note",
            },
        ),
        (
            ["--force"],
            {
                "action": "store_true",
                "help": "Force overwrite of existing files and settings",
                "dest": "force",
            },
        ),
    ]
    return parse_args_with_defaults(arg_defs, ["global", script_name])


def enable_ssh(passwords: bool = False):
    sshd_dir = "/etc/ssh/sshd_config.d"
    custom_conf = os.path.join(sshd_dir, "sensos.conf")
    password_setting = "yes" if passwords else "no"

    create_dir(sshd_dir, owner="root", mode=0o755)
    config = f"""\
# Set by SensOS
PasswordAuthentication {password_setting}
PubkeyAuthentication yes
"""
    write_file(custom_conf, config, mode=0o644, user="root")
    print(
        f"‚úÖ SSH passwords are {'enabled' if passwords else 'disabled'} in {custom_conf}."
    )

    privileged_shell("systemctl enable ssh")
    privileged_shell("systemctl restart ssh")
    print("‚úÖ SSH service enabled and restarted.")
    print("üîÑ A reboot is still recommended to ensure all changes take full effect.")


def generate_wireguard_keys(network_name, force):
    if not os.path.isdir(WG_DIR):
        print(
            f"‚ùå Error: Configuration directory '{WG_DIR}' does not exist.",
            file=sys.stderr,
        )
        sys.exit(1)

    private_key_file = os.path.join(WG_DIR, f"{network_name}-private.key")
    public_key_file = os.path.join(WG_DIR, f"{network_name}-public.key")

    print("üîë Generating new WireGuard key pair...")
    private_key, rc = privileged_shell("wg genkey")
    public_key, rc2 = privileged_shell(f"echo {private_key} | wg pubkey")

    if not private_key or not public_key:
        print("‚ùå Error: Failed to generate WireGuard keys.", file=sys.stderr)
        sys.exit(1)

    write_file(private_key_file, private_key, mode=0o600, user="root")
    write_file(public_key_file, public_key, mode=0o644, user="root")

    print(f"‚úÖ WireGuard keys generated:")
    print(f"  - Private Key stored in: {private_key_file} (permissions set to 600)")
    print(f"  - Public Key stored in: {public_key_file}")
    return public_key


def register_peer(
    config_server, port, network_name, wg_public_key, api_password, subnet, note=""
):
    if wg_public_key is None:
        print(
            "‚ùå Error: Invalid WireGuard public key. Skipping peer registration.",
            file=sys.stderr,
        )
        sys.exit(1)

    server_url = f"http://{config_server}:{port}/register-peer"
    print(f"üì° Registering device on network '{network_name}' with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={
            "network_name": network_name,
            "subnet_offset": subnet,
            "note": note if note else None,
        },
        headers=headers,
    )

    print(f"Status Code: {response.status_code}")
    print(f"Response Text: {response.text}")

    if response.status_code != 200:
        print(
            f"‚ùå Failed to register. Server response: {response.text}", file=sys.stderr
        )
        sys.exit(1)

    data = response.json()
    wg_ip = data.get("wg_ip")
    server_pubkey = data.get("wg_public_key")
    wg_public_ip = data.get("wg_public_ip")
    wg_port = data.get("wg_port")

    if not all([wg_ip, server_pubkey, wg_public_ip, wg_port]):
        print(
            "‚ùå Error: Incomplete data received from peer registration.",
            file=sys.stderr,
        )
        sys.exit(1)

    ip_parts = wg_ip.split(".")
    if len(ip_parts) == 4:
        hostname = f"{network_name}_{ip_parts[2]}_{ip_parts[3]}"
    else:
        print("‚ùå Error: Malformed WireGuard IP address: %s" % wg_ip, file=sys.stderr)
        sys.exit(1)

    register_wireguard_key(config_server, port, wg_ip, wg_public_key, api_password)
    return wg_ip, hostname, server_pubkey, wg_public_ip, wg_port


def register_wireguard_key(config_server, port, wg_ip, wg_public_key, api_password):
    if wg_ip is None or wg_public_key is None:
        print(
            "‚ùå Error: Missing WireGuard IP or public key for registration.",
            file=sys.stderr,
        )
        sys.exit(1)

    server_url = f"http://{config_server}:{port}/register-wireguard-key"
    print(f"üîë Registering WireGuard public key with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={"wg_ip": wg_ip, "wg_public_key": wg_public_key},
        headers=headers,
    )

    if response.status_code != 200:
        print(
            f"‚ùå Failed to register WireGuard key. Server response: {response.text}",
            file=sys.stderr,
        )
        sys.exit(1)
    else:
        print(f"‚úÖ WireGuard key registered for {wg_ip}.")


def change_hostname(new_hostname):
    if new_hostname is None:
        print("‚ùå Error: New hostname is invalid. Aborting.", file=sys.stderr)
        sys.exit(1)

    current_hostname, rc = privileged_shell("hostname")
    if current_hostname != new_hostname:
        print(f"üîÑ Changing hostname from {current_hostname} to {new_hostname}...")

        write_file("/etc/hostname", new_hostname + "\n", mode=0o644, user="root")

        # Backup and update /etc/hosts
        privileged_shell("cp /etc/hosts /etc/hosts.bak")
        hosts_content = read_file("/etc/hosts").splitlines()
        updated_hosts = [
            f"127.0.1.1 {new_hostname}" if "127.0.1.1" in line else line
            for line in hosts_content
        ]
        new_hosts_content = "\n".join(updated_hosts) + "\n"
        write_file("/etc/hosts", new_hosts_content, mode=0o644, user="root")

        print(
            f"‚úÖ Hostname changed manually to {new_hostname} (will apply after restart)"
        )
    else:
        print(f"‚úÖ Hostname is already set to {new_hostname}")


def write_wireguard_config(
    wg_ip, server_pubkey, wg_public_ip, wg_port, network_name, wg_keepalive
):
    if not all([wg_ip, server_pubkey, wg_public_ip, wg_port]):
        print(
            "‚ùå Error: Incomplete WireGuard data. Configuration not written.",
            file=sys.stderr,
        )
        sys.exit(1)

    private_key_file = os.path.join(WG_DIR, f"{network_name}-private.key")
    wg_config_file = os.path.join(WG_DIR, f"{network_name}.conf")
    private_key = read_file(private_key_file).strip()
    if not private_key:
        print(
            "‚ùå Error: Private key is missing. Cannot write configuration.",
            file=sys.stderr,
        )
        sys.exit(1)

    ip_parts = wg_ip.split(".")
    if len(ip_parts) != 4:
        print(f"‚ùå Error: Invalid IP format received: {wg_ip}", file=sys.stderr)
        sys.exit(1)

    base_ip = f"{ip_parts[0]}.{ip_parts[1]}"
    allowed_ips = f"{base_ip}.0.0/16"

    config = f"""
[Interface]
PrivateKey = {private_key}
Address = {wg_ip}/32

[Peer]
PublicKey = {server_pubkey}
Endpoint = {wg_public_ip}:{wg_port} 
AllowedIPs = {allowed_ips}
PersistentKeepalive = {wg_keepalive}
"""

    write_file(wg_config_file, config, 0o600, "root", "root")
    print(
        f"‚úÖ WireGuard configuration written to {wg_config_file} (permissions set to 600)"
    )
    print(f"üîß Allowed IPs set to {allowed_ips}")


def generate_ssh_keys(force):
    ssh_dir = os.path.join(SENSOS_ADMIN_HOME, ".ssh")
    create_dir(ssh_dir, owner="sensos-admin", mode=0o700)
    private_key_file = os.path.join(ssh_dir, "id_ed25519")
    public_key_file = f"{private_key_file}.pub"

    print("üîë Generating new SSH key pair...")
    privileged_shell(f"ssh-keygen -t ed25519 -f {private_key_file} -q -N ''")

    if not os.path.exists(public_key_file):
        print(
            f"‚ùå Error: Failed to generate SSH public key at {public_key_file}",
            file=sys.stderr,
        )
        sys.exit(1)

    set_permissions_and_owner(private_key_file, 0o600, user="sensos-admin")
    set_permissions_and_owner(public_key_file, 0o644, user="sensos-admin")

    print(f"‚úÖ SSH key generated at {private_key_file} and {public_key_file}.")


def extract_ssh_key_params(public_key_file):
    if not os.path.exists(public_key_file):
        print(
            f"‚ùå Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        return None, None, None, None, None
    try:
        with open(public_key_file, "r") as f:
            key_parts = f.read().strip().split()
        if len(key_parts) < 2:
            print(
                f"‚ùå Error: Invalid SSH key format in '{public_key_file}'.",
                file=sys.stderr,
            )
            return None, None, None, None, None
        key_type = key_parts[0]
        key_comment = key_parts[-1] if len(key_parts) > 2 else None
        key_info, _ = privileged_shell(f"ssh-keygen -lf {public_key_file}")
        if not key_info:
            print(
                f"‚ùå Error: Failed to extract key details from '{public_key_file}'.",
                file=sys.stderr,
            )
            return key_type, None, key_comment, None, None
        key_info_parts = key_info.split()
        if len(key_info_parts) < 2:
            return key_type, None, key_comment, None, None
        fingerprint = key_info_parts[1]
        try:
            key_size = int(key_info_parts[0])
        except ValueError:
            print(
                f"‚ö†Ô∏è Warning: Failed to parse key size '{key_info_parts[0]}'. Defaulting to None.",
                file=sys.stderr,
            )
            key_size = None
        expires_at = None
        if key_comment:
            try:
                if "expires:" in key_comment:
                    expires_str = key_comment.split("expires:")[-1].strip()
                    expires_at = datetime.datetime.strptime(
                        expires_str, "%Y-%m-%d"
                    ).isoformat()
            except ValueError:
                print(
                    f"‚ö†Ô∏è Warning: Could not parse expiration date from comment '{key_comment}'.",
                    file=sys.stderr,
                )
                expires_at = None
        return key_type, key_size, key_comment, fingerprint, expires_at
    except Exception as e:
        print(
            f"‚ùå Exception while processing '{public_key_file}': {e}", file=sys.stderr
        )
        return None, None, None, None, None


def exchange_ssh_keys(config_server, port, wg_ip, api_password):
    ssh_dir = os.path.join(SENSOS_ADMIN_HOME, ".ssh")
    public_key_file = os.path.join(ssh_dir, "id_ed25519.pub")
    authorized_keys_file = os.path.join(ssh_dir, "authorized_keys")
    if not os.path.exists(public_key_file):
        print(
            f"‚ùå Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        sys.exit(1)
    username = "sensos-admin"
    uid = pwd.getpwnam(username).pw_uid
    key_type, key_size, key_comment, fingerprint, expires_at = extract_ssh_key_params(
        public_key_file
    )
    if not key_type or not fingerprint:
        print(
            f"‚ùå Failed to extract SSH key details from {public_key_file}",
            file=sys.stderr,
        )
        return
    payload = {
        "wg_ip": wg_ip,
        "username": username,
        "uid": uid,
        "ssh_public_key": open(public_key_file).read().strip(),
        "key_type": key_type,
        "key_size": key_size if key_size else None,
        "key_comment": key_comment,
        "fingerprint": fingerprint,
        "expires_at": expires_at if expires_at else None,
    }
    if not all([wg_ip, payload["ssh_public_key"], key_type, fingerprint]):
        print("‚ùå Error: Incomplete SSH key data. Aborting exchange.", file=sys.stderr)
        sys.exit(1)
    server_url = f"http://{config_server}:{port}/exchange-ssh-keys"
    print(f"üîë Registering SSH public key with {server_url}...")
    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(server_url, json=payload, headers=headers)
    if response.status_code != 200:
        print(
            f"‚ùå Failed to register SSH key. Server response: {response.text}",
            file=sys.stderr,
        )
        sys.exit(1)
    print(f"‚úÖ SSH key registered successfully for peer with WireGuard IP {wg_ip}.")
    server_public_key = response.json().get("ssh_public_key")
    if not server_public_key:
        print("‚ùå No SSH public key returned from server.", file=sys.stderr)
        sys.exit(1)
    with open(authorized_keys_file, "a") as auth_keys:
        auth_keys.write(server_public_key + "\n")
    print(f"‚úÖ Server public key added to {authorized_keys_file}.")


def configure_wireguard(args, api_password):
    config_file = os.path.join(WG_DIR, f"{args.network}.conf")

    print("Reconfiguring WireGuard...")

    wg_public_key = generate_wireguard_keys(args.network, args.force)
    if wg_public_key is None:
        print(
            "‚ùå WireGuard key generation/retrieval failed. Skipping WireGuard configuration.",
            file=sys.stderr,
        )
        sys.exit(1)

    wg_ip, hostname, server_pubkey, wg_public_ip, wg_port = register_peer(
        args.config_server,
        args.port,
        args.network,
        wg_public_key,
        api_password,
        args.subnet,
        note=args.note,
    )

    if not wg_ip:
        print(
            "‚ùå Peer registration failed. Skipping WireGuard configuration.",
            file=sys.stderr,
        )
        sys.exit(1)

    if args.wg_endpoint:
        print(
            f"‚ö†Ô∏è Overriding WireGuard endpoint IP: {wg_public_ip} ‚Üí {args.wg_endpoint}"
        )
        wg_public_ip = args.wg_endpoint

    write_wireguard_config(
        wg_ip,
        server_pubkey,
        wg_public_ip,
        wg_port,
        args.network,
        args.wg_keepalive,
    )

    change_hostname(hostname)
    return wg_ip, wg_public_ip


def configure_ssh(args, api_password, wg_ip):
    generate_ssh_keys(args.force)
    if wg_ip:
        exchange_ssh_keys(args.config_server, args.port, wg_ip, api_password)
    else:
        print(
            "‚ùå No WG IP available; cannot exchange SSH keys.",
            file=sys.stderr,
        )
        sys.exit(1)


def write_client_settings(args, server_wg_ip, client_wg_ip, endpoint_ip):
    settings_dir = "/sensos/etc"
    settings_file = os.path.join(settings_dir, "network.conf")
    create_dir(settings_dir, owner="sensos-admin", mode=0o755)

    ssh_tunnel_ip = args.ssh_tunnel_ip or endpoint_ip

    content = (
        f"SERVER_WG_IP={server_wg_ip}\n"
        f"CLIENT_WG_IP={client_wg_ip}\n"
        f"SERVER_PORT={args.port}\n"
        f"NETWORK_NAME={args.network}\n"
        f"WG_ENDPOINT_IP={endpoint_ip}\n"
        f"SSH_TUNNEL_IP={ssh_tunnel_ip}\n"
        f"SSH_TUNNEL_PORT={args.ssh_tunnel_port}\n"
        f"CONNECTIVITY_MODE={args.connectivity_mode}\n"
        f"BANDWIDTH_POLICY={args.bandwidth_policy}\n"
    )

    write_file(settings_file, content, mode=0o644, user="sensos-admin")
    print(f"‚úÖ Client network settings written to {settings_file}")


def sensos_config_files_exist(args):
    # List of files produced by this script
    files_to_check = [
        os.path.join(WG_DIR, f"{args.network}-private.key"),
        os.path.join(WG_DIR, f"{args.network}-public.key"),
        os.path.join(WG_DIR, f"{args.network}.conf"),
        os.path.join(SENSOS_ADMIN_HOME, ".ssh", "id_ed25519"),
        os.path.join(SENSOS_ADMIN_HOME, ".ssh", "id_ed25519.pub"),
        SENSOS_NET_CONF,
    ]
    return [f for f in files_to_check if os.path.exists(f)]


def remove_sensos_config_files(network_name):
    # Remove all the files we generate
    files_to_remove = [
        os.path.join(WG_DIR, f"{network_name}-private.key"),
        os.path.join(WG_DIR, f"{network_name}-public.key"),
        os.path.join(WG_DIR, f"{network_name}.conf"),
        os.path.join(SENSOS_ADMIN_HOME, ".ssh", "id_ed25519"),
        os.path.join(SENSOS_ADMIN_HOME, ".ssh", "id_ed25519.pub"),
        SENSOS_NET_CONF,
    ]
    for f in files_to_remove:
        remove_file(f)  # Assuming remove_file does not error if not present


def main():
    username = pwd.getpwuid(os.geteuid()).pw_name
    if username not in ("sensos-admin", "root"):
        print(
            f"\n‚ùå This script must be run as 'sensos-admin' or 'root', not '{username}'.",
            file=sys.stderr,
        )
        print(
            "   Please switch users: sudo -u sensos-admin ... or run as root\n",
            file=sys.stderr,
        )
        sys.exit(1)

    setup_logging()
    args = parse_args()

    existing_files = sensos_config_files_exist(args)

    if not args.force and existing_files:
        print(
            "\n‚ùå Existing SensOS config files detected:\n  "
            + "\n  ".join(existing_files)
        )
        print("Aborting. Use --force to remove all configs and proceed.\n")
        sys.exit(1)

    if args.force:
        remove_sensos_config_files(args.network)

    print("üöÄ Starting device configuration...")

    api_password = get_api_password(args.config_server, args.port)
    if not api_password:
        print("‚ùå Critical error: API password not obtained. Aborting configuration.")
        sys.exit(1)

    client_wg_ip, wg_public_ip = configure_wireguard(args, api_password)
    if not client_wg_ip:
        print("‚ùå WireGuard configuration failed. Aborting.")
        sys.exit(1)

    server_wg_ip = compute_api_server_wg_ip(client_wg_ip)
    if not server_wg_ip:
        print("‚ùå Failed to compute API server WireGuard IP. Aborting.")
        sys.exit(1)

    endpoint_ip = args.wg_endpoint or wg_public_ip
    endpoint_ip = endpoint_ip.split(":")[0] if ":" in endpoint_ip else endpoint_ip
    write_client_settings(args, server_wg_ip, client_wg_ip, endpoint_ip)
    configure_ssh(args, api_password, client_wg_ip)

    enable_ssh(passwords=args.enable_ssh_passwords)

    if args.connectivity_mode == "always":
        privileged_shell(f"systemctl enable wg-quick@{args.network}")
        privileged_shell(f"systemctl start wg-quick@{args.network}")
        if not args.no_connectivity_checks:
            privileged_shell("systemctl enable monitor-connectivity.service")
    else:
        privileged_shell(f"systemctl stop wg-quick@{args.network}")
        privileged_shell(f"systemctl disable wg-quick@{args.network}")
        privileged_shell(f"systemctl enable set-network-config.service")

    print("‚úÖ Configuration complete. Reboot now and check connectivity.")


if __name__ == "__main__":
    main()
