#!/usr/bin/env python3
import os
import sys
import stat
import argparse
import requests
import datetime
import subprocess
import configparser
import base64
import json
import shutil
import socket
import psutil
import time

sys.path.insert(0, "/sensos/lib")
from utils import *

WG_DIR = "/etc/wireguard"


def parse_args():
    script_name = os.path.basename(sys.argv[0])
    if script_name.endswith(".py"):
        script_name = script_name[:-3]
    elif "." in script_name:
        script_name = script_name.split(".")[0]
    script_name = script_name.replace("-", "_")

    arg_defs = [
        (
            ["--config-server"],
            {
                "help": "Configuration server hostname or IP (default: localhost)",
                "dest": "config_server",
            },
        ),
        (
            ["--port"],
            {
                "help": "Server port (default: 8765)",
                "dest": "port",
                "type": int,
                "default": 8765,
            },
        ),
        (
            ["--network"],
            {
                "help": "Network name (default: sensos)",
                "dest": "network",
                "default": "sensos",
            },
        ),
        (
            ["--subnet"],
            {
                "help": "Subnet offset for WireGuard IP assignment (default: 1, i.e., x.x.1.1)",
                "dest": "subnet",
                "type": int,
                "default": 1,
            },
        ),
        (
            ["--wg-endpoint"],
            {
                "help": "Override WireGuard endpoint IP (default: use server-assigned IP)",
                "dest": "wg_endpoint",
            },
        ),
        (
            ["--wg-keepalive"],
            {
                "help": "WireGuard persistent keepalive interval (default: 25 seconds)",
                "dest": "wg_keepalive",
                "type": int,
                "default": 25,
            },
        ),
        (
            ["--enable-ssh-passwords"],
            {
                "action": "store_true",
                "help": "Enable SSH password authentication (default: disabled)",
                "dest": "enable_ssh_passwords",
            },
        ),
        (
            ["--connectivity-profile"],
            {
                "help": "Connectivity profile: unrestricted, restricted, or offline (offline implies --no-connectivity-checks)",
                "choices": ["unrestricted", "restricted", "offline"],
                "dest": "connectivity_profile",
            },
        ),
        (
            ["--no-connectivity-checks"],
            {
                "action": "store_true",
                "help": "Skip connectivity check service",
                "dest": "no_connectivity_checks",
            },
        ),
        (
            ["--note"],
            {
                "help": "Optional note or description to register with the device (default: empty)",
                "dest": "note",
            },
        ),
        (
            ["--force"],
            {
                "action": "store_true",
                "help": "Force overwrite of existing files and settings",
                "dest": "force",
            },
        ),
    ]
    return parse_args_with_defaults(arg_defs, ["global", script_name])


def enable_wireguard(netname: str):
    service_name = f"wg-quick@{netname}.service"
    run_command(f"sudo systemctl enable {service_name}")
    run_command(f"sudo systemctl start {service_name}")
    print(f"âœ… WireGuard service {service_name} enabled and started.")


def enable_ssh(passwords: bool = False):
    """Enable SSH and configure password authentication based on the `passwords` flag."""
    sshd_dir = "/etc/ssh/sshd_config.d"
    custom_conf = os.path.join(sshd_dir, "sensos.conf")
    password_setting = "yes" if passwords else "no"

    # Make sure directory exists
    run_command(f"sudo mkdir -p {sshd_dir}")

    # Write settings to our override file
    config = f"""\
# Set by SensOS
PasswordAuthentication {password_setting}
PubkeyAuthentication yes
"""
    run_command(f"echo '{config}' | sudo tee {custom_conf} > /dev/null")

    print(
        f"âœ… SSH passwords are {'enabled' if passwords else 'disabled'} in {custom_conf}."
    )

    # Enable and start SSH service
    run_command("sudo systemctl enable ssh")
    run_command("sudo systemctl restart ssh")

    print("âœ… SSH service enabled and restarted.")
    print("ğŸ”„ A reboot is still recommended to ensure all changes take full effect.")


def generate_wireguard_keys(network_name, force):
    """Generate or retrieve WireGuard key pair with network-specific file names. Returns public key."""
    if not os.path.isdir(WG_DIR):
        print(
            f"âŒ Error: Configuration directory '{WG_DIR}' does not exist.",
            file=sys.stderr,
        )
        return None

    private_key_file = os.path.join(WG_DIR, f"{network_name}-private.key")
    public_key_file = os.path.join(WG_DIR, f"{network_name}-public.key")

    if os.path.exists(private_key_file) and os.path.exists(public_key_file):
        print(
            f"â„¹ï¸ Existing WireGuard keys found for network '{network_name}'. Using existing keys."
        )
        public_key = sudo_read_file(public_key_file)
        return public_key

    if (
        os.path.exists(private_key_file) or os.path.exists(public_key_file)
    ) and not force:
        print(
            "âŒ Incomplete key files exist. Use --force to regenerate keys.",
            file=sys.stderr,
        )
        return None

    print("ğŸ”‘ Generating new WireGuard key pair...")
    private_key = run_command("wg genkey")
    public_key = run_command(f"echo {private_key} | wg pubkey")

    if not private_key or not public_key:
        print("âŒ Error: Failed to generate valid WireGuard keys.", file=sys.stderr)
        return None

    run_command(f"echo '{private_key}' | sudo tee {private_key_file} > /dev/null")
    run_command(f"sudo chmod 600 {private_key_file}")
    run_command(f"echo '{public_key}' | sudo tee {public_key_file} > /dev/null")

    print(f"âœ… WireGuard keys generated:")
    print(f"  - Private Key stored in: {private_key_file} (permissions set to 600)")
    print(f"  - Public Key stored in: {public_key_file}")
    return public_key


def register_peer(
    config_server, port, network_name, wg_public_key, api_password, subnet, note=""
):
    """Register the device with the WireGuard server and return its assigned IP and connection details."""
    if wg_public_key is None:
        print(
            "âŒ Error: Invalid WireGuard public key. Skipping peer registration.",
            file=sys.stderr,
        )
        return None, None, None, None, None

    server_url = f"http://{config_server}:{port}/register-peer"
    print(f"ğŸ“¡ Registering device on network '{network_name}' with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={
            "network_name": network_name,
            "subnet_offset": subnet,
            "note": note if note else None,
        },
        headers=headers,
    )

    print(f"Status Code: {response.status_code}")
    print(f"Response Text: {response.text}")

    if response.status_code != 200:
        print(
            f"âŒ Failed to register. Server response: {response.text}", file=sys.stderr
        )
        return None, None, None, None, None

    data = response.json()
    wg_ip = data.get("wg_ip")
    server_pubkey = data.get("wg_public_key")
    wg_public_ip = data.get("wg_public_ip")
    wg_port = data.get("wg_port")

    if not all([wg_ip, server_pubkey, wg_public_ip, wg_port]):
        print(
            "âŒ Error: Incomplete data received from peer registration.",
            file=sys.stderr,
        )
        return None, None, None, None, None

    hostname = compute_hostname(network_name, wg_ip)
    if hostname is None:
        print(
            "âŒ Error: Could not compute hostname due to invalid IP.", file=sys.stderr
        )
        return None, None, None, None, None

    register_wireguard_key(config_server, port, wg_ip, wg_public_key, api_password)
    return wg_ip, hostname, server_pubkey, wg_public_ip, wg_port


def register_wireguard_key(config_server, port, wg_ip, wg_public_key, api_password):
    """Registers the WireGuard public key for this device."""
    if wg_ip is None or wg_public_key is None:
        print(
            "âŒ Error: Missing WireGuard IP or public key for registration.",
            file=sys.stderr,
        )
        return

    server_url = f"http://{config_server}:{port}/register-wireguard-key"
    print(f"ğŸ”‘ Registering WireGuard public key with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={"wg_ip": wg_ip, "wg_public_key": wg_public_key},
        headers=headers,
    )

    if response.status_code != 200:
        print(
            f"âŒ Failed to register WireGuard key. Server response: {response.text}",
            file=sys.stderr,
        )
    else:
        print(f"âœ… WireGuard key registered for {wg_ip}.")


def change_hostname(new_hostname):
    """Change the system hostname to the computed value."""
    if new_hostname is None:
        print(
            "âŒ Error: New hostname is invalid. Skipping hostname change.",
            file=sys.stderr,
        )
        return

    current_hostname = run_command("hostname")
    if current_hostname != new_hostname:
        print(f"ğŸ”„ Changing hostname from {current_hostname} to {new_hostname}...")
        run_command(f"echo '{new_hostname}' | sudo tee /etc/hostname > /dev/null")
        run_command("sudo cp /etc/hosts /etc/hosts.bak")
        hosts = run_command("cat /etc/hosts").splitlines()
        updated_hosts = []
        for line in hosts:
            if "127.0.1.1" in line:
                updated_hosts.append(f"127.0.1.1 {new_hostname}")
            else:
                updated_hosts.append(line)
        run_command(
            f"echo '{chr(10).join(updated_hosts)}' | sudo tee /etc/hosts > /dev/null"
        )
        print(
            f"âœ… Hostname changed manually to {new_hostname} (will apply after restart)"
        )
    else:
        print(f"âœ… Hostname is already set to {new_hostname}")


def write_wireguard_config(
    wg_ip, server_pubkey, wg_public_ip, wg_port, network_name, force, wg_keepalive
):
    """Write the WireGuard configuration file with secure permissions."""
    if not all([wg_ip, server_pubkey, wg_public_ip, wg_port]):
        print(
            "âŒ Error: Incomplete WireGuard data. Configuration not written.",
            file=sys.stderr,
        )
        return

    private_key_file = os.path.join(WG_DIR, f"{network_name}-private.key")
    wg_config_file = os.path.join(WG_DIR, f"{network_name}.conf")
    if os.path.exists(wg_config_file):
        print(
            f"âš ï¸ WireGuard config file {wg_config_file} already exists.", file=sys.stderr
        )
        if not force:
            print(
                "ğŸš« Aborting to prevent overwriting existing configuration. Use --force to override.",
                file=sys.stderr,
            )
            return

    private_key = sudo_read_file(private_key_file)
    if not private_key:
        print(
            "âŒ Error: Private key is missing. Cannot write configuration.",
            file=sys.stderr,
        )
        return

    ip_parts = wg_ip.split(".")
    if len(ip_parts) != 4:
        print(f"âŒ Error: Invalid IP format received: {wg_ip}", file=sys.stderr)
        return

    base_ip = f"{ip_parts[0]}.{ip_parts[1]}"
    allowed_ips = f"{base_ip}.0.0/16"

    config = f"""
[Interface]
PrivateKey = {private_key}
Address = {wg_ip}/32

[Peer]
PublicKey = {server_pubkey}
Endpoint = {wg_public_ip}:{wg_port} 
AllowedIPs = {allowed_ips}
PersistentKeepalive = {wg_keepalive}
"""

    run_command(f"echo '{config}' | sudo tee {wg_config_file} > /dev/null")
    run_command(f"sudo chmod 600 {wg_config_file}")
    if not os.path.exists(wg_config_file):
        print(
            f"âŒ Expected WireGuard config not found at {wg_config_file}",
            file=sys.stderr,
        )
    else:
        print(
            f"âœ… WireGuard configuration written to {wg_config_file} (permissions set to 600)"
        )
    print(f"ğŸ”§ Allowed IPs set to {allowed_ips}")


def generate_ssh_keys(force):
    """Generate an SSH key pair if not already present."""
    ssh_dir = os.path.expanduser("~/.ssh")
    os.makedirs(ssh_dir, exist_ok=True)
    private_key_file = os.path.join(ssh_dir, "id_ed25519")
    public_key_file = f"{private_key_file}.pub"
    if os.path.exists(private_key_file) and os.path.exists(public_key_file):
        print("âš ï¸ SSH keys already exist.", file=sys.stderr)
        if not force:
            print(
                "ğŸš« Aborting to prevent overwriting existing keys. Use --force to override.",
                file=sys.stderr,
            )
            return
    print("ğŸ”‘ Generating new SSH key pair...")
    run_command(f"ssh-keygen -t ed25519 -f {private_key_file} -q -N ''")
    if not os.path.exists(public_key_file):
        print(
            f"âŒ Error: Failed to generate SSH public key at {public_key_file}",
            file=sys.stderr,
        )
        return
    os.chmod(private_key_file, 0o600)
    print(f"âœ… SSH key generated at {private_key_file} and {public_key_file}.")


def extract_ssh_key_params(public_key_file):
    """Extract SSH key type, size, fingerprint, comment, and expiration date, handling missing files."""
    if not os.path.exists(public_key_file):
        print(
            f"âŒ Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        return None, None, None, None, None
    try:
        with open(public_key_file, "r") as f:
            key_parts = f.read().strip().split()
        if len(key_parts) < 2:
            print(
                f"âŒ Error: Invalid SSH key format in '{public_key_file}'.",
                file=sys.stderr,
            )
            return None, None, None, None, None
        key_type = key_parts[0]
        key_comment = key_parts[-1] if len(key_parts) > 2 else None
        key_info = run_command(f"ssh-keygen -lf {public_key_file}")
        if not key_info:
            print(
                f"âŒ Error: Failed to extract key details from '{public_key_file}'.",
                file=sys.stderr,
            )
            return key_type, None, key_comment, None, None
        key_info_parts = key_info.split()
        if len(key_info_parts) < 2:
            return key_type, None, key_comment, None, None
        fingerprint = key_info_parts[1]
        try:
            key_size = int(key_info_parts[0])
        except ValueError:
            print(
                f"âš ï¸ Warning: Failed to parse key size '{key_info_parts[0]}'. Defaulting to None.",
                file=sys.stderr,
            )
            key_size = None
        expires_at = None
        if key_comment:
            try:
                if "expires:" in key_comment:
                    expires_str = key_comment.split("expires:")[-1].strip()
                    expires_at = datetime.datetime.strptime(
                        expires_str, "%Y-%m-%d"
                    ).isoformat()
            except ValueError:
                print(
                    f"âš ï¸ Warning: Could not parse expiration date from comment '{key_comment}'.",
                    file=sys.stderr,
                )
                expires_at = None
        return key_type, key_size, key_comment, fingerprint, expires_at
    except Exception as e:
        print(
            f"âŒ Exception while processing '{public_key_file}': {e}", file=sys.stderr
        )
        return None, None, None, None, None


def exchange_ssh_keys(config_server, port, wg_ip, api_password):
    """Registers an SSH public key for this device using its WireGuard IP."""
    ssh_dir = os.path.expanduser("~/.ssh")
    public_key_file = os.path.join(ssh_dir, "id_ed25519.pub")
    authorized_keys_file = os.path.join(ssh_dir, "authorized_keys")
    if not os.path.exists(public_key_file):
        print(
            f"âŒ Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        return
    username = os.getenv("USER") or run_command("whoami")
    uid = os.getuid()
    key_type, key_size, key_comment, fingerprint, expires_at = extract_ssh_key_params(
        public_key_file
    )
    if not key_type or not fingerprint:
        print(
            f"âŒ Failed to extract SSH key details from {public_key_file}",
            file=sys.stderr,
        )
        return
    payload = {
        "wg_ip": wg_ip,
        "username": username,
        "uid": uid,
        "ssh_public_key": open(public_key_file).read().strip(),
        "key_type": key_type,
        "key_size": key_size if key_size else None,
        "key_comment": key_comment,
        "fingerprint": fingerprint,
        "expires_at": expires_at if expires_at else None,
    }
    if not all([wg_ip, payload["ssh_public_key"], key_type, fingerprint]):
        print("âŒ Error: Incomplete SSH key data. Aborting exchange.", file=sys.stderr)
        return
    server_url = f"http://{config_server}:{port}/exchange-ssh-keys"
    print(f"ğŸ”‘ Registering SSH public key with {server_url}...")
    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(server_url, json=payload, headers=headers)
    if response.status_code != 200:
        print(
            f"âŒ Failed to register SSH key. Server response: {response.text}",
            file=sys.stderr,
        )
        return
    print(f"âœ… SSH key registered successfully for peer with WireGuard IP {wg_ip}.")
    server_public_key = response.json().get("ssh_public_key")
    if not server_public_key:
        print("âŒ No SSH public key returned from server.", file=sys.stderr)
        return
    with open(authorized_keys_file, "a") as auth_keys:
        auth_keys.write(server_public_key + "\n")
    print(f"âœ… Server public key added to {authorized_keys_file}.")
    print(f"âœ… SSH key registered successfully for peer with WireGuard IP {wg_ip}.")


def check_existing_wireguard_config(config_file, network_name, args, api_password):
    """
    Checks whether an existing WireGuard config matches the API records.
    Returns a tuple:
        (should_reconfigure: bool, local_wg_ip: Optional[str])
    """
    if not os.path.exists(config_file):
        print("âŒ No local WireGuard configuration file found.", file=sys.stderr)
        return True, None

    print(f"Found WireGuard config at {config_file}.")
    local_config = parse_local_config(config_file)

    if "wg_ip" not in local_config:
        print("âŒ Local config does not contain a valid WireGuard IP.", file=sys.stderr)
        return True, None

    local_wg_ip = local_config["wg_ip"]
    print(f"Local WireGuard IP: {local_wg_ip}. Querying /get-peer-info...")

    url = f"http://{args.config_server}:{args.port}/get-peer-info?ip_address={local_wg_ip}"
    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}

    try:
        resp = requests.get(url, headers=headers, timeout=5)
        if resp.status_code != 200:
            print(
                f"âŒ /get-peer-info returned {resp.status_code}; reconfiguring.",
                file=sys.stderr,
            )
            return True, local_wg_ip

        peer_info = resp.json()
        if not peer_info.get("exists"):
            print(
                "âŒ Peer not registered in API. Reconfiguration needed.",
                file=sys.stderr,
            )
            return True, local_wg_ip

        local_server_pubkey = local_config.get("server_pubkey")
        local_peer_pubkey = read_file(
            os.path.join(WG_DIR, f"{network_name}-public.key")
        )

        if local_server_pubkey == peer_info.get(
            "network_wg_public_key"
        ) and local_peer_pubkey == peer_info.get("peer_wg_public_key"):
            print("âœ… Local WireGuard configuration matches API records.")
            if not args.force:
                choice = input("Reconfigure WireGuard? (y/N): ").strip().lower()
                return choice == "y", local_wg_ip
            return True, local_wg_ip
        else:
            print(
                "âŒ Mismatch in WireGuard keys detected. Reconfiguration required.",
                file=sys.stderr,
            )
            return True, local_wg_ip

    except Exception as e:
        print(f"âŒ Error accessing /get-peer-info: {e}", file=sys.stderr)
        return True, local_wg_ip


def configure_wireguard(args, api_password):
    config_file = os.path.join(WG_DIR, f"{args.network}.conf")

    reconfigure_wg, local_wg_ip = check_existing_wireguard_config(
        config_file, args.network, args, api_password
    )

    if not reconfigure_wg:
        print("Keeping existing WireGuard configuration.")
        return local_wg_ip or args.config_server

    print("Reconfiguring WireGuard...")

    wg_public_key = generate_wireguard_keys(args.network, args.force)
    if wg_public_key is None:
        print(
            "âŒ WireGuard key generation/retrieval failed. Skipping WireGuard configuration.",
            file=sys.stderr,
        )
        return None

    wg_ip, hostname, server_pubkey, wg_public_ip, wg_port = register_peer(
        args.config_server,
        args.port,
        args.network,
        wg_public_key,
        api_password,
        args.subnet,
        note=args.note,
    )

    if not wg_ip:
        print(
            "âŒ Peer registration failed. Skipping WireGuard configuration.",
            file=sys.stderr,
        )
        return None

    if args.wg_endpoint:
        print(
            f"âš ï¸ Overriding WireGuard endpoint IP: {wg_public_ip} â†’ {args.wg_endpoint}"
        )
        wg_public_ip = args.wg_endpoint

    write_wireguard_config(
        wg_ip,
        server_pubkey,
        wg_public_ip,
        wg_port,
        args.network,
        args.force,
        args.wg_keepalive,
    )

    change_hostname(hostname)
    return wg_ip, wg_public_ip


def configure_ssh(args, api_password):
    """
    Check if SSH keys exist and whether the registered SSH public key (via /get-peer-info)
    matches the local SSH public key. If missing or mismatched, or if the user chooses to
    reconfigure (unless --force), generate new SSH keys and exchange them with the server.
    """
    ssh_private = os.path.expanduser("~/.ssh/id_ed25519")
    ssh_public = os.path.expanduser("~/.ssh/id_ed25519.pub")
    reconfigure_ssh = True
    if os.path.exists(ssh_private) and os.path.exists(ssh_public):
        local_ssh_pubkey = read_file(ssh_public)
        config_file = os.path.join(WG_DIR, f"{args.network}.conf")
        wg_config_content = sudo_read_file(config_file)
        if wg_config_content:
            local_config = parse_local_config(config_file)
            if "wg_ip" in local_config:
                local_wg_ip = local_config["wg_ip"]
                print(
                    f"Querying /get-peer-info for SSH keys using WG IP {local_wg_ip}..."
                )
                url = f"http://{args.config_server}:{args.port}/get-peer-info?ip_address={local_wg_ip}"
                headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
                try:
                    resp = requests.get(url, headers=headers, timeout=5)
                    if resp.status_code == 200:
                        peer_info = resp.json()
                        if peer_info.get("ssh_public_key") == local_ssh_pubkey:
                            print("SSH key configuration matches API records.")
                            if not args.force:
                                choice = (
                                    input("Reconfigure SSH keys? (y/N): ")
                                    .strip()
                                    .lower()
                                )
                                reconfigure_ssh = choice == "y"
                            else:
                                reconfigure_ssh = True
                        else:
                            print(
                                "âŒ Local SSH key does not match API. Reconfiguration required.",
                                file=sys.stderr,
                            )
                    else:
                        print(
                            f"âŒ /get-peer-info returned {resp.status_code} for SSH; reconfiguring SSH.",
                            file=sys.stderr,
                        )
                except Exception as e:
                    print(
                        "âŒ Error accessing /get-peer-info for SSH:", e, file=sys.stderr
                    )
            else:
                print(
                    "âŒ No WG IP found in local config; cannot verify SSH keys.",
                    file=sys.stderr,
                )
        else:
            print(
                "âŒ No local WireGuard config available (cannot read with sudo); skipping SSH key exchange.",
                file=sys.stderr,
            )
    else:
        print("SSH keys not found; new keys will be generated.")

    if reconfigure_ssh:
        print("Reconfiguring SSH keys...")
        generate_ssh_keys(args.force)
        config_file = os.path.join(WG_DIR, f"{args.network}.conf")
        wg_config_content = sudo_read_file(config_file)
        if wg_config_content:
            local_config = parse_local_config(config_file)
            if "wg_ip" in local_config:
                wg_ip = local_config["wg_ip"]
                exchange_ssh_keys(args.config_server, args.port, wg_ip, api_password)
            else:
                print(
                    "âŒ No WG IP available in config; cannot exchange SSH keys.",
                    file=sys.stderr,
                )
        else:
            print(
                "âŒ No local WG config available; skipping SSH key exchange.",
                file=sys.stderr,
            )
    else:
        print("Keeping existing SSH key configuration.")


def write_client_settings(args, server_wg_ip, client_wg_ip, endpoint_ip):
    settings_dir = "/sensos/etc"
    settings_file = os.path.join(settings_dir, "network.conf")
    os.makedirs(settings_dir, exist_ok=True)

    content = (
        f"SERVER_WG_IP={server_wg_ip}\n"
        f"CLIENT_WG_IP={client_wg_ip}\n"
        f"SERVER_PORT={args.port}\n"
        f"NETWORK_NAME={args.network}\n"
        f"WG_ENDPOINT_IP={endpoint_ip}\n"
    )
    if args.connectivity_profile:
        content += f"CONNECTIVITY_PROFILE={args.connectivity_profile}\n"

    with open(settings_file, "w") as f:
        f.write(content)

    os.chmod(settings_file, 0o644)
    print(f"âœ… Client network settings written to {settings_file}")


def main():
    setup_logging()

    args = parse_args()

    if args.connectivity_profile == "offline":
        args.no_connectivity_checks = True
    if args.connectivity_profile:
        print(f"ğŸ“¡ Connectivity profile: {args.connectivity_profile}")

    print("ğŸš€ Starting device configuration...")
    api_password = get_api_password(args.config_server, args.port)
    if not api_password:
        print("âŒ Critical error: API password not obtained. Aborting configuration.")
        return
    client_wg_ip, wg_public_ip = configure_wireguard(args, api_password)
    if not client_wg_ip:
        print("âŒ WireGuard configuration failed. Aborting.")
        return
    server_wg_ip = compute_api_server_wg_ip(client_wg_ip)
    if not server_wg_ip:
        print("âŒ Failed to compute API server WireGuard IP. Aborting.")
        return
    configure_ssh(args, api_password)
    print("Starting WireGuard and SSH services...")
    try:
        enable_wireguard(args.network)
        enable_ssh(passwords=args.enable_ssh_passwords)
        print("âœ… Services started successfully.")
    except Exception as e:
        print(f"âŒ Error starting services: {e}")

    endpoint_ip = args.wg_endpoint or wg_public_ip
    endpoint_ip = endpoint_ip.split(":")[0] if ":" in endpoint_ip else endpoint_ip
    write_client_settings(args, server_wg_ip, client_wg_ip, endpoint_ip)

    if not args.no_connectivity_checks:
        enable_service("monitor-connectivity.service")
    else:
        print(
            "â„¹ï¸ No-connectivity-checks mode active. Skipping connectivity check service enablement."
        )
    print("âœ… Configuration complete. Reboot now and check connectivity.")


if __name__ == "__main__":
    main()
