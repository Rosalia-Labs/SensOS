#!/usr/bin/env python3
import os
import sys
import pwd
import stat
import argparse
import requests
import datetime
import subprocess
import configparser
import base64
import json
import shutil
import socket
import psutil
import time

sys.path.insert(0, "/sensos/lib")
from utils import *

WG_DIR = "/etc/wireguard"
SENSOS_ADMIN_HOME = "/home/sensos-admin"


def parse_args():
    script_name = os.path.basename(sys.argv[0])
    if script_name.endswith(".py"):
        script_name = script_name[:-3]
    elif "." in script_name:
        script_name = script_name.split(".")[0]
    script_name = script_name.replace("-", "_")

    arg_defs = [
        (
            ["--config-server"],
            {
                "help": "Configuration server hostname or IP (default: localhost)",
                "dest": "config_server",
            },
        ),
        (
            ["--port"],
            {
                "help": "Server port (default: 8765)",
                "dest": "port",
                "type": int,
                "default": 8765,
            },
        ),
        (
            ["--network"],
            {
                "help": "Network name (default: sensos)",
                "dest": "network",
                "default": "sensos",
            },
        ),
        (
            ["--subnet"],
            {
                "help": "Subnet offset for WireGuard IP assignment (default: 1, i.e., x.x.1.1)",
                "dest": "subnet",
                "type": int,
                "default": 1,
            },
        ),
        (
            ["--wg-endpoint"],
            {
                "help": "Override WireGuard endpoint IP (default: use server-assigned IP)",
                "dest": "wg_endpoint",
            },
        ),
        (
            ["--wg-keepalive"],
            {
                "help": "WireGuard persistent keepalive interval (default: 25 seconds)",
                "dest": "wg_keepalive",
                "type": int,
                "default": 0,
            },
        ),
        (
            ["--enable-ssh-passwords"],
            {
                "action": "store_true",
                "help": "Enable SSH password authentication (default: disabled)",
                "dest": "enable_ssh_passwords",
            },
        ),
        (
            ["--ssh-tunnel-port"],
            {
                "help": "SSH port for clients to use when connecting to the server (default: 2345)",
                "dest": "ssh_tunnel_port",
                "type": int,
                "default": 2345,
            },
        ),
        (
            ["--ssh-tunnel-ip"],
            {
                "help": "Server hostname or IP for SSH access (default: same as WireGuard endpoint/server)",
                "dest": "ssh_tunnel_ip",
            },
        ),
        (
            ["--connectivity-mode"],
            {
                "help": "Network interface behavior: always, ondemand, offline",
                "choices": ["always", "ondemand", "offline"],
                "dest": "connectivity_mode",
                "default": "always",
            },
        ),
        (
            ["--bandwidth-policy"],
            {
                "help": "Bandwidth policy: unrestricted, restricted",
                "choices": ["unrestricted", "restricted"],
                "dest": "bandwidth_policy",
                "default": "unrestricted",
            },
        ),
        (
            ["--no-connectivity-checks"],
            {
                "action": "store_true",
                "help": "Skip connectivity check service",
                "dest": "no_connectivity_checks",
            },
        ),
        (
            ["--note"],
            {
                "help": "Optional note or description to register with the device (default: empty)",
                "dest": "note",
            },
        ),
        (
            ["--force"],
            {
                "action": "store_true",
                "help": "Force overwrite of existing files and settings",
                "dest": "force",
            },
        ),
    ]
    return parse_args_with_defaults(arg_defs, ["global", script_name])


def enable_wireguard(netname: str):
    service_name = f"wg-quick@{netname}.service"
    run_sudo_shell(f"systemctl enable {service_name}")
    run_sudo_shell(f"systemctl start {service_name}")
    print(f"‚úÖ WireGuard service {service_name} enabled and started.")


def enable_ssh(passwords: bool = False):
    """Enable SSH and configure password authentication based on the `passwords` flag."""
    sshd_dir = "/etc/ssh/sshd_config.d"
    custom_conf = os.path.join(sshd_dir, "sensos.conf")
    password_setting = "yes" if passwords else "no"

    # Make sure directory exists
    run_sudo_shell(f"mkdir -p {sshd_dir}")

    # Write settings to our override file
    config = f"""\
# Set by SensOS
PasswordAuthentication {password_setting}
PubkeyAuthentication yes
"""
    sudo_write_file(config, custom_conf, mode=0o644, user="root")

    print(
        f"‚úÖ SSH passwords are {'enabled' if passwords else 'disabled'} in {custom_conf}."
    )

    # Enable and start SSH service
    run_sudo_shell("systemctl enable ssh")
    run_sudo_shell("systemctl restart ssh")

    print("‚úÖ SSH service enabled and restarted.")
    print("üîÑ A reboot is still recommended to ensure all changes take full effect.")


def generate_wireguard_keys(network_name, force):
    """Generate or retrieve WireGuard key pair with network-specific file names. Returns public key."""
    if not os.path.isdir(WG_DIR):
        print(
            f"‚ùå Error: Configuration directory '{WG_DIR}' does not exist.",
            file=sys.stderr,
        )
        sys.exit(1)

    private_key_file = os.path.join(WG_DIR, f"{network_name}-private.key")
    public_key_file = os.path.join(WG_DIR, f"{network_name}-public.key")

    print("üîë Generating new WireGuard key pair...")
    private_key = run_command("wg genkey")
    public_key = run_command(f"echo {private_key} | wg pubkey")

    if not private_key or not public_key:
        print("‚ùå Error: Failed to generate WireGuard keys.", file=sys.stderr)
        sys.exit(1)

    sudo_write_file(private_key, private_key_file, mode=0o600, user="root")
    sudo_write_file(public_key, public_key_file, mode=0o644, user="root")

    print(f"‚úÖ WireGuard keys generated:")
    print(f"  - Private Key stored in: {private_key_file} (permissions set to 600)")
    print(f"  - Public Key stored in: {public_key_file}")
    return public_key


def register_peer(
    config_server, port, network_name, wg_public_key, api_password, subnet, note=""
):
    """Register the device with the WireGuard server and return its assigned IP and connection details."""
    if wg_public_key is None:
        print(
            "‚ùå Error: Invalid WireGuard public key. Skipping peer registration.",
            file=sys.stderr,
        )
        sys.exit(1)

    server_url = f"http://{config_server}:{port}/register-peer"
    print(f"üì° Registering device on network '{network_name}' with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={
            "network_name": network_name,
            "subnet_offset": subnet,
            "note": note if note else None,
        },
        headers=headers,
    )

    print(f"Status Code: {response.status_code}")
    print(f"Response Text: {response.text}")

    if response.status_code != 200:
        print(
            f"‚ùå Failed to register. Server response: {response.text}", file=sys.stderr
        )
        sys.exit(1)

    data = response.json()
    wg_ip = data.get("wg_ip")
    server_pubkey = data.get("wg_public_key")
    wg_public_ip = data.get("wg_public_ip")
    wg_port = data.get("wg_port")

    if not all([wg_ip, server_pubkey, wg_public_ip, wg_port]):
        print(
            "‚ùå Error: Incomplete data received from peer registration.",
            file=sys.stderr,
        )
        sys.exit(1)

    hostname = compute_hostname(network_name, wg_ip)
    if hostname is None:
        print(
            "‚ùå Error: Could not compute hostname due to invalid IP.", file=sys.stderr
        )
        sys.exit(1)

    register_wireguard_key(config_server, port, wg_ip, wg_public_key, api_password)
    return wg_ip, hostname, server_pubkey, wg_public_ip, wg_port


def register_wireguard_key(config_server, port, wg_ip, wg_public_key, api_password):
    """Registers the WireGuard public key for this device."""
    if wg_ip is None or wg_public_key is None:
        print(
            "‚ùå Error: Missing WireGuard IP or public key for registration.",
            file=sys.stderr,
        )
        sys.exit(1)

    server_url = f"http://{config_server}:{port}/register-wireguard-key"
    print(f"üîë Registering WireGuard public key with {server_url}...")

    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(
        server_url,
        json={"wg_ip": wg_ip, "wg_public_key": wg_public_key},
        headers=headers,
    )

    if response.status_code != 200:
        print(
            f"‚ùå Failed to register WireGuard key. Server response: {response.text}",
            file=sys.stderr,
        )
        sys.exit(1)
    else:
        print(f"‚úÖ WireGuard key registered for {wg_ip}.")


def change_hostname(new_hostname):
    """Change the system hostname to the computed value."""
    if new_hostname is None:
        print("‚ùå Error: New hostname is invalid. Aborting.", file=sys.stderr)
        sys.exit(1)

    current_hostname = run_command("hostname")
    if current_hostname != new_hostname:
        print(f"üîÑ Changing hostname from {current_hostname} to {new_hostname}...")

        # Safely write new hostname
        sudo_write_file(new_hostname + "\n", "/etc/hostname", mode=0o644, user="root")

        # Backup and update /etc/hosts
        run_sudo_shell("cp /etc/hosts /etc/hosts.bak")
        hosts = run_command("cat /etc/hosts").splitlines()
        updated_hosts = [
            f"127.0.1.1 {new_hostname}" if "127.0.1.1" in line else line
            for line in hosts
        ]
        new_hosts_content = "\n".join(updated_hosts) + "\n"
        sudo_write_file(new_hosts_content, "/etc/hosts", mode=0o644, user="root")

        print(
            f"‚úÖ Hostname changed manually to {new_hostname} (will apply after restart)"
        )
    else:
        print(f"‚úÖ Hostname is already set to {new_hostname}")


def write_wireguard_config(
    wg_ip, server_pubkey, wg_public_ip, wg_port, network_name, wg_keepalive
):
    """Write the WireGuard configuration file with secure permissions."""
    if not all([wg_ip, server_pubkey, wg_public_ip, wg_port]):
        print(
            "‚ùå Error: Incomplete WireGuard data. Configuration not written.",
            file=sys.stderr,
        )
        sys.exit(1)

    private_key_file = os.path.join(WG_DIR, f"{network_name}-private.key")
    wg_config_file = os.path.join(WG_DIR, f"{network_name}.conf")
    private_key = sudo_read_file(private_key_file).strip()
    if not private_key:
        print(
            "‚ùå Error: Private key is missing. Cannot write configuration.",
            file=sys.stderr,
        )
        sys.exit(1)

    ip_parts = wg_ip.split(".")
    if len(ip_parts) != 4:
        print(f"‚ùå Error: Invalid IP format received: {wg_ip}", file=sys.stderr)
        sys.exit(1)

    base_ip = f"{ip_parts[0]}.{ip_parts[1]}"
    allowed_ips = f"{base_ip}.0.0/16"

    config = f"""
[Interface]
PrivateKey = {private_key}
Address = {wg_ip}/32

[Peer]
PublicKey = {server_pubkey}
Endpoint = {wg_public_ip}:{wg_port} 
AllowedIPs = {allowed_ips}
PersistentKeepalive = {wg_keepalive}
"""

    sudo_write_file(config, wg_config_file, 0o600, "root", "root")
    print(
        f"‚úÖ WireGuard configuration written to {wg_config_file} (permissions set to 600)"
    )
    print(f"üîß Allowed IPs set to {allowed_ips}")


def generate_ssh_keys(force):
    """Generate an SSH key pair if not already present."""
    ssh_dir = os.path.join(SENSOS_ADMIN_HOME, ".ssh")
    os.makedirs(ssh_dir, exist_ok=True)
    set_permissions_and_owner(ssh_dir, 0o700, user="sensos-admin")
    private_key_file = os.path.join(ssh_dir, "id_ed25519")
    public_key_file = f"{private_key_file}.pub"

    print("üîë Generating new SSH key pair...")
    run_command(f"ssh-keygen -t ed25519 -f {private_key_file} -q -N ''")

    if not os.path.exists(public_key_file):
        print(
            f"‚ùå Error: Failed to generate SSH public key at {public_key_file}",
            file=sys.stderr,
        )
        sys.exit(1)

    set_permissions_and_owner(private_key_file, 0o600, user="sensos-admin")
    set_permissions_and_owner(public_key_file, 0o644, user="sensos-admin")

    print(f"‚úÖ SSH key generated at {private_key_file} and {public_key_file}.")


def extract_ssh_key_params(public_key_file):
    """Extract SSH key type, size, fingerprint, comment, and expiration date, handling missing files."""
    if not os.path.exists(public_key_file):
        print(
            f"‚ùå Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        return None, None, None, None, None
    try:
        with open(public_key_file, "r") as f:
            key_parts = f.read().strip().split()
        if len(key_parts) < 2:
            print(
                f"‚ùå Error: Invalid SSH key format in '{public_key_file}'.",
                file=sys.stderr,
            )
            return None, None, None, None, None
        key_type = key_parts[0]
        key_comment = key_parts[-1] if len(key_parts) > 2 else None
        key_info = run_command(f"ssh-keygen -lf {public_key_file}")
        if not key_info:
            print(
                f"‚ùå Error: Failed to extract key details from '{public_key_file}'.",
                file=sys.stderr,
            )
            return key_type, None, key_comment, None, None
        key_info_parts = key_info.split()
        if len(key_info_parts) < 2:
            return key_type, None, key_comment, None, None
        fingerprint = key_info_parts[1]
        try:
            key_size = int(key_info_parts[0])
        except ValueError:
            print(
                f"‚ö†Ô∏è Warning: Failed to parse key size '{key_info_parts[0]}'. Defaulting to None.",
                file=sys.stderr,
            )
            key_size = None
        expires_at = None
        if key_comment:
            try:
                if "expires:" in key_comment:
                    expires_str = key_comment.split("expires:")[-1].strip()
                    expires_at = datetime.datetime.strptime(
                        expires_str, "%Y-%m-%d"
                    ).isoformat()
            except ValueError:
                print(
                    f"‚ö†Ô∏è Warning: Could not parse expiration date from comment '{key_comment}'.",
                    file=sys.stderr,
                )
                expires_at = None
        return key_type, key_size, key_comment, fingerprint, expires_at
    except Exception as e:
        print(
            f"‚ùå Exception while processing '{public_key_file}': {e}", file=sys.stderr
        )
        return None, None, None, None, None


def exchange_ssh_keys(config_server, port, wg_ip, api_password):
    """Registers an SSH public key for this device using its WireGuard IP."""
    ssh_dir = os.path.join(SENSOS_ADMIN_HOME, ".ssh")
    public_key_file = os.path.join(ssh_dir, "id_ed25519.pub")
    authorized_keys_file = os.path.join(ssh_dir, "authorized_keys")
    if not os.path.exists(public_key_file):
        print(
            f"‚ùå Error: SSH public key file '{public_key_file}' not found.",
            file=sys.stderr,
        )
        sys.exit(1)
    username = "sensos-admin"
    uid = pwd.getpwnam(username).pw_uid
    key_type, key_size, key_comment, fingerprint, expires_at = extract_ssh_key_params(
        public_key_file
    )
    if not key_type or not fingerprint:
        print(
            f"‚ùå Failed to extract SSH key details from {public_key_file}",
            file=sys.stderr,
        )
        return
    payload = {
        "wg_ip": wg_ip,
        "username": username,
        "uid": uid,
        "ssh_public_key": open(public_key_file).read().strip(),
        "key_type": key_type,
        "key_size": key_size if key_size else None,
        "key_comment": key_comment,
        "fingerprint": fingerprint,
        "expires_at": expires_at if expires_at else None,
    }
    if not all([wg_ip, payload["ssh_public_key"], key_type, fingerprint]):
        print("‚ùå Error: Incomplete SSH key data. Aborting exchange.", file=sys.stderr)
        sys.exit(1)
    server_url = f"http://{config_server}:{port}/exchange-ssh-keys"
    print(f"üîë Registering SSH public key with {server_url}...")
    headers = {"Authorization": f"Basic {get_basic_auth(api_password)}"}
    response = requests.post(server_url, json=payload, headers=headers)
    if response.status_code != 200:
        print(
            f"‚ùå Failed to register SSH key. Server response: {response.text}",
            file=sys.stderr,
        )
        sys.exit(1)
    print(f"‚úÖ SSH key registered successfully for peer with WireGuard IP {wg_ip}.")
    server_public_key = response.json().get("ssh_public_key")
    if not server_public_key:
        print("‚ùå No SSH public key returned from server.", file=sys.stderr)
        sys.exit(1)
    with open(authorized_keys_file, "a") as auth_keys:
        auth_keys.write(server_public_key + "\n")
    print(f"‚úÖ Server public key added to {authorized_keys_file}.")


def configure_wireguard(args, api_password):
    config_file = os.path.join(WG_DIR, f"{args.network}.conf")

    print("Reconfiguring WireGuard...")

    wg_public_key = generate_wireguard_keys(args.network, args.force)
    if wg_public_key is None:
        print(
            "‚ùå WireGuard key generation/retrieval failed. Skipping WireGuard configuration.",
            file=sys.stderr,
        )
        sys.exit(1)

    wg_ip, hostname, server_pubkey, wg_public_ip, wg_port = register_peer(
        args.config_server,
        args.port,
        args.network,
        wg_public_key,
        api_password,
        args.subnet,
        note=args.note,
    )

    if not wg_ip:
        print(
            "‚ùå Peer registration failed. Skipping WireGuard configuration.",
            file=sys.stderr,
        )
        sys.exit(1)

    if args.wg_endpoint:
        print(
            f"‚ö†Ô∏è Overriding WireGuard endpoint IP: {wg_public_ip} ‚Üí {args.wg_endpoint}"
        )
        wg_public_ip = args.wg_endpoint

    write_wireguard_config(
        wg_ip,
        server_pubkey,
        wg_public_ip,
        wg_port,
        args.network,
        args.wg_keepalive,
    )

    change_hostname(hostname)
    return wg_ip, wg_public_ip


def configure_ssh(args, api_password, wg_ip):
    """
    Generates a new SSH key pair and registers the public key with the server.
    Assumes a clean slate (keys do not exist yet). Requires wg_ip from previous step.
    """
    generate_ssh_keys(args.force)
    if wg_ip:
        exchange_ssh_keys(args.config_server, args.port, wg_ip, api_password)
    else:
        print(
            "‚ùå No WG IP available; cannot exchange SSH keys.",
            file=sys.stderr,
        )
        sys.exit(1)


def write_client_settings(args, server_wg_ip, client_wg_ip, endpoint_ip):
    settings_dir = "/sensos/etc"
    settings_file = os.path.join(settings_dir, "network.conf")
    os.makedirs(settings_dir, exist_ok=True)

    ssh_tunnel_ip = args.ssh_tunnel_ip or endpoint_ip

    content = (
        f"SERVER_WG_IP={server_wg_ip}\n"
        f"CLIENT_WG_IP={client_wg_ip}\n"
        f"SERVER_PORT={args.port}\n"
        f"NETWORK_NAME={args.network}\n"
        f"WG_ENDPOINT_IP={endpoint_ip}\n"
        f"SSH_TUNNEL_IP={ssh_tunnel_ip}\n"
        f"SSH_TUNNEL_PORT={args.ssh_tunnel_port}\n"
        f"CONNECTIVITY_MODE={args.connectivity_mode}\n"
        f"BANDWIDTH_POLICY={args.bandwidth_policy}\n"
    )

    with open(settings_file, "w") as f:
        f.write(content)

    os.chmod(settings_file, 0o644)
    print(f"‚úÖ Client network settings written to {settings_file}")


def main():
    setup_logging()

    args = parse_args()

    wg_config_file = os.path.join(WG_DIR, f"{args.network}.conf")
    wg_private_key = os.path.join(WG_DIR, f"{args.network}-private.key")
    wg_public_key = os.path.join(WG_DIR, f"{args.network}-public.key")
    ssh_private = os.path.join(SENSOS_ADMIN_HOME, ".ssh/id_ed25519")
    ssh_public = os.path.join(SENSOS_ADMIN_HOME, ".ssh/id_ed25519.pub")
    sensos_net_conf = "/sensos/etc/network.conf"

    preexisting = []
    for f in [
        wg_config_file,
        wg_private_key,
        wg_public_key,
        ssh_private,
        ssh_public,
        sensos_net_conf,
    ]:
        if os.path.exists(f):
            preexisting.append(f)

    if preexisting and not args.force:
        print("\n‚ùå Existing configuration detected:")
        for f in preexisting:
            print(f"    {f}")
        print("\nAborting. Use --force to completely regenerate all keys/configs.\n")
        sys.exit(1)

    if args.force and preexisting:
        print("‚ö†Ô∏è  --force specified, removing old configuration...")
        for f in preexisting:
            try:
                os.remove(f)
                print(f"  Removed: {f}")
            except Exception as e:
                print(f"  Could not remove {f}: {e}")

    if args.connectivity_mode != "always":
        args.no_connectivity_checks = True

    print("üöÄ Starting device configuration...")
    api_password = get_api_password(args.config_server, args.port)
    if not api_password:
        print("‚ùå Critical error: API password not obtained. Aborting configuration.")
        sys.exit(1)
    client_wg_ip, wg_public_ip = configure_wireguard(args, api_password)
    if not client_wg_ip:
        print("‚ùå WireGuard configuration failed. Aborting.")
        sys.exit(1)
    server_wg_ip = compute_api_server_wg_ip(client_wg_ip)
    if not server_wg_ip:
        print("‚ùå Failed to compute API server WireGuard IP. Aborting.")
        sys.exit(1)
    configure_ssh(args, api_password, client_wg_ip)
    print("Starting WireGuard and SSH services...")
    try:
        enable_wireguard(args.network)
        enable_ssh(passwords=args.enable_ssh_passwords)
        print("‚úÖ Services started successfully.")
    except Exception as e:
        print(f"‚ùå Error starting services: {e}")

    endpoint_ip = args.wg_endpoint or wg_public_ip
    endpoint_ip = endpoint_ip.split(":")[0] if ":" in endpoint_ip else endpoint_ip
    write_client_settings(args, server_wg_ip, client_wg_ip, endpoint_ip)

    if not args.no_connectivity_checks:
        enable_service("monitor-connectivity.service")
    else:
        print(
            "‚ÑπÔ∏è No-connectivity-checks mode active. Skipping connectivity check service enablement."
        )
    print("‚úÖ Configuration complete. Reboot now and check connectivity.")


if __name__ == "__main__":
    main()
