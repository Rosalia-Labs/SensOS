#!/bin/bash -e
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Rosalia Labs LLC

#
# config-sensos-storage
#
# Mounts external storage to /sensos/data, with safeguards.

script_name=$(basename "$0")
DATA_MOUNT="/sensos/data"

source /sensos/lib/load-defaults.sh
source /sensos/lib/parse-switches.sh

declare -A default_vars
load_defaults "$script_name" default_vars

get_default() {
    local varname="$1"
    local fallback="$2"
    echo "${default_vars[$varname]:-$fallback}"
}

register_option --device device "Block device to format/mount" "$(get_default device)"
register_option --no-fstab no_fstab "Skip adding fstab entry (non-persistent mount)" "false"

# Parse CLI
parse_switches "$script_name" "$@"

# Validate
if [[ -z "$device" ]]; then
    echo "‚ùå --device must be specified (e.g., /dev/sda, /dev/nvme0n1, etc.)."
    echo
    echo "Hint: Run 'lsblk -o NAME,SIZE,TYPE,MOUNTPOINT' to list available devices."
    lsblk -o NAME,SIZE,TYPE,MOUNTPOINT
    exit 1
fi

has_partition_table() {
    local device="$1"
    if [[ -z "$device" || ! -b "$device" ]]; then
        echo "‚ùå $device is not a block device." >&2
        return 1
    fi

    if sudo parted -s "$device" print &>/dev/null; then
        echo "true"
    else
        echo "false"
    fi
}

is_device_mounted() {
    local device="$1"
    if mount | grep -q "^$device "; then
        echo "true"
    else
        echo "false"
    fi
}

get_first_partition() {
    local device="$1"
    sudo lsblk -nrpo NAME "$device" | grep -v "^$device\$" | head -n 1
}

get_filesystem_type() {
    local part="$1"

    if [[ -z "$part" || ! -b "$part" ]]; then
        echo ""
        return
    fi

    sudo blkid -s TYPE -o value "$part"
}

wait_for_partition() {
    local device="$1"
    for i in {1..10}; do
        local part
        part=$(get_first_partition "$device")
        if [[ -n "$part" && -b "$part" ]]; then
            echo "$part"
            return
        fi
        sleep 0.5
    done
    echo ""
}

prompt_for_filesystem_type() {
    read -p "‚ùì Use Windows-compatible filesystem (exfat)? [y/N] " winfs
    if [[ "$winfs" == [yY] ]]; then
        FS_TYPE_ARG="exfat"
    else
        FS_TYPE_ARG="ext4"
    fi
    MAKE_FS=true
}

# Validate device existence
if ! [[ -b "$device" ]]; then
    echo "‚ùå $device is not a block device."
    exit 1
fi

# Unmount if necessary
if [[ "$(is_device_mounted "$device")" == "true" ]]; then
    echo "‚ö†Ô∏è  Device $device is currently mounted."
    read -p "‚ùì Unmount $device before proceeding? [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        echo "üîß Unmounting $device..."
        if sudo umount "$device"; then
            echo "‚úÖ Unmounted"
        else
            echo "‚ùå Failed to unmount $device ‚Äî it may be busy."
            echo "   Tip: Run \`lsof +f -- $device\` or \`mount | grep $device\` to investigate."
            exit 1
        fi
    else
        echo "‚ùå Aborting. Cannot proceed with mounted device."
        exit 1
    fi
fi

# PARTITION TABLE LOGIC
if has_partition_table "$device"; then
    echo "‚úÖ Partition table found on $device"
    echo "üìÑ Current partition table:"
    sudo lsblk -o NAME,SIZE,FSTYPE,LABEL,UUID,MOUNTPOINT "$device"

    read -p "‚ùì Overwrite existing partition table on $device with a new GPT table? This will erase all data. [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        create_table=true
    else
        echo "‚û°Ô∏è  Keeping existing partition table."
        create_table=false
    fi
else
    echo "‚ö†Ô∏è  No partition table found on $device"
    read -p "‚ùì Create a new GPT partition table on $device? This will erase all data. [Y/n] " confirm
    if [[ "$confirm" == [nN] ]]; then
        echo "‚ùå Aborting. No changes made."
        exit 1
    fi
    create_table=true
fi

if [[ "$create_table" == true ]]; then
    echo "üõ†Ô∏è  Creating GPT partition table and a single primary partition..."
    sudo parted -s "$device" mklabel gpt
    sudo parted -s -a optimal "$device" mkpart primary 0% 100%
    sync
    echo "‚úÖ Partition table is ready"
    echo "üåÄ Informing kernel of partition changes..."
    sudo partprobe "$device" || sudo udevadm settle
    sleep 1
fi

# Wait for partition
PARTITION=$(wait_for_partition "$device")
if [[ -z "$PARTITION" ]]; then
    echo "‚ùå Could not find partition on $device"
    exit 1
fi

# FILESYSTEM LOGIC
fstype=$(get_filesystem_type "$PARTITION")
if [[ -n "$fstype" ]]; then
    echo "‚úÖ Detected existing filesystem: $fstype"
    read -p "‚ùì Do you want to overwrite it with a new filesystem? This will erase all data. [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        prompt_for_filesystem_type
    else
        echo "‚û°Ô∏è  Keeping existing filesystem. Continuing without changes."
        FS_TYPE_ARG="$fstype"
        MAKE_FS=false
    fi
else
    echo "‚ÑπÔ∏è  No filesystem detected on $PARTITION."
    read -p "‚ùì Create new filesystem? [Y/n] " confirm
    if [[ "$confirm" == [nN] ]]; then
        echo "‚ùå Aborting. No filesystem will be created."
        exit 1
    fi
    prompt_for_filesystem_type
fi

if [[ "$MAKE_FS" == true ]]; then
    echo "üßº Creating $FS_TYPE_ARG filesystem on $PARTITION..."
    case "$FS_TYPE_ARG" in
    ext4)
        sudo mkfs.ext4 -F "$PARTITION"
        ;;
    exfat)
        sudo mkfs.exfat -n SENSOS_DATA "$PARTITION"
        ;;
    *)
        echo "‚ùå Unsupported filesystem type: $FS_TYPE_ARG"
        exit 1
        ;;
    esac
    echo "‚úÖ Filesystem created on $PARTITION"
fi

if [[ -n "$(sudo ls -A "$DATA_MOUNT")" ]]; then
    echo "‚ö†Ô∏è  $DATA_MOUNT is not empty."
    read -p "‚ùì Remove all contents of $DATA_MOUNT before mounting? [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        echo "üßπ Removing existing contents..."
        sudo rm -rf "${DATA_MOUNT:?}/"*
        echo "‚úÖ Directory cleaned"
    else
        read -p "‚ùì Mount device over existing contents anyway? [y/N] " confirm_mount
        if [[ "$confirm_mount" == [yY] ]]; then
            echo "‚û°Ô∏è  Will mount over existing contents at $DATA_MOUNT"
        else
            echo "‚ùå Aborting. Mount point must be clean or explicitly allowed."
            exit 1
        fi
    fi
else
    echo "‚úÖ $DATA_MOUNT is empty and ready."
fi

read -p "‚ùì Proceed with mounting the device? [Y/n] " confirm_mount
if [[ "$confirm_mount" == [nN] ]]; then
    echo "‚ùå Aborting before mount."
    exit 1
fi

if [[ "$FS_TYPE_ARG" == "exfat" ]]; then
    uid_val=$(id -u sensos-admin)
    gid_val=$(getent group sensos-data | cut -d: -f3)
    sudo mount -t exfat -o uid="$uid_val",gid="$gid_val",umask=0002 "$PARTITION" "$DATA_MOUNT"
else
    sudo mount "$PARTITION" "$DATA_MOUNT"
fi
echo "‚úÖ Mount complete: $PARTITION ‚Üí $DATA_MOUNT"

if [[ -n "$(sudo ls -A "$DATA_MOUNT")" ]]; then
    echo "‚ö†Ô∏è  Files exist on $DATA_MOUNT after mounting."
    echo "‚ùì Choose what to remove:"
    echo "   [a] All contents of $DATA_MOUNT"
    echo "   [d] Only $DATA_MOUNT/database"
    echo "   [s] Skip (do not delete anything)"
    read -p "Your choice [a/d/s]? " cleanup_choice

    # Mountpoint check for all delete options:
    if [[ "$cleanup_choice" =~ [aAdD] ]]; then
        if ! mountpoint -q "$DATA_MOUNT"; then
            echo "‚ùå $DATA_MOUNT is not a mountpoint! Aborting cleanup to avoid deleting files from the root filesystem."
            exit 1
        fi
    fi

    case "$cleanup_choice" in
    a | A)
        read -p "‚ùó Are you sure you want to permanently delete ALL contents of $DATA_MOUNT? [y/N] " confirm_all
        if [[ "$confirm_all" == [yY] ]]; then
            echo "üßπ Removing ALL contents of $DATA_MOUNT..."
            sudo rm -rf "${DATA_MOUNT:?}/"*
            echo "‚úÖ All contents removed."
        else
            echo "‚ùå Skipped deletion of all contents."
        fi
        ;;
    d | D)
        if [[ -d "$DATA_MOUNT/database" ]]; then
            read -p "‚ùó Are you sure you want to delete $DATA_MOUNT/database? [y/N] " confirm_db
            if [[ "$confirm_db" == [yY] ]]; then
                echo "üßπ Removing $DATA_MOUNT/database..."
                sudo rm -rf "$DATA_MOUNT/database"
                echo "‚úÖ database directory removed."
            else
                echo "‚ùå Skipped deletion of database."
            fi
        else
            echo "‚ÑπÔ∏è  $DATA_MOUNT/database does not exist ‚Äî nothing to remove."
        fi
        ;;
    *)
        echo "‚û°Ô∏è  Skipping deletion."
        ;;
    esac
fi

if [[ "$no_fstab" == "true" ]]; then
    echo "‚è≠Ô∏è  Skipping fstab update (flag --no-fstab was set)."
else
    echo "üìÑ Checking for existing /etc/fstab entry for $PARTITION or $DATA_MOUNT..."
    # Refresh UUID and LABEL info in case it changed after mkfs
    uuid=$(sudo blkid -s UUID -o value "$PARTITION")
    label=$(sudo blkid -s LABEL -o value "$PARTITION")
    if [[ -z "$uuid" && -z "$label" ]]; then
        echo "‚ö†Ô∏è  No UUID or LABEL found for $PARTITION ‚Äî falling back to using device path in /etc/fstab."
        device_ref="$PARTITION"
    else
        if [[ -n "$uuid" ]]; then
            device_ref="UUID=$uuid"
        else
            device_ref="LABEL=$label"
        fi
    fi

    if grep -Eq "^\s*(${device_ref}|${PARTITION})\s+${DATA_MOUNT}\s" /etc/fstab; then
        echo "‚úÖ Found existing fstab entry:"
        grep -n -E "^\s*(${device_ref}|${PARTITION})\s+${DATA_MOUNT}\s" /etc/fstab
        read -p "‚ùì Keep this fstab entry? [Y/n] " keep
        if [[ "$keep" == [nN] ]]; then
            echo "‚ùå Please edit /etc/fstab manually to remove or update the entry (see above for line number)."
            exit 1
        else
            echo "‚úÖ Keeping existing fstab entry."
        fi
    else
        echo "‚ÑπÔ∏è  No valid fstab entry found for $PARTITION at $DATA_MOUNT."
        read -p "‚ùì Add new fstab entry to make mount persistent? [Y/n] " add
        if [[ "$add" != [nN] ]]; then
            echo "üßπ Removing any existing /etc/fstab entry for $DATA_MOUNT..."
            sudo sed -i.bak -r "\|^[^#].+\s+$DATA_MOUNT\s+|d" /etc/fstab
            echo "üîß Adding fstab entry:"
            if [[ "$FS_TYPE_ARG" == "exfat" ]]; then
                uid_val=$(id -u sensos-admin)
                gid_val=$(getent group sensos-data | cut -d: -f3)
                fstab_line="$device_ref $DATA_MOUNT exfat defaults,nofail,uid=$uid_val,gid=$gid_val,umask=0002,noauto,x-systemd.automount,x-systemd.device-timeout=10 0 0"
            else
                fstab_line="$device_ref $DATA_MOUNT ext4 defaults,nofail,noatime 0 2"
            fi
            echo "$fstab_line"
            echo "$fstab_line" | sudo tee -a /etc/fstab >/dev/null
            echo "‚úÖ fstab updated"
        else
            echo "‚û°Ô∏è  Skipping fstab update. Mount will not persist after reboot."
        fi
    fi
fi

# Write identifying info onto the mounted storage
echo "Creating device info on the mounted storage..."
sudo /sensos/service_scripts/cache-sys-info.sh

# Make sure proper permissions
sudo chown -R sensos-admin:sensos-data "$DATA_MOUNT"
sudo chmod -R 2775 "$DATA_MOUNT"
