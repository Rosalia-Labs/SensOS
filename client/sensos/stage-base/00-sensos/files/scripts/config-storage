#!/bin/bash -e
#
# config-sensos-storage
#
# Mounts external storage to /sensos/data, with safeguards.
#

DATA_MOUNT="/sensos/data"
PERMANENT=false
DEVICE=""
DEVICE_HINT=""
SKIP_FSTAB=false

script_name=$(basename "$0")

# Load from defaults.conf
if [[ -f /sensos/lib/load-defaults.sh ]]; then
    source /sensos/lib/load-defaults.sh
    declare -A default_vars
    load_defaults "$script_name" default_vars
    DEVICE_HINT="${default_vars[device_hint]:-}"
fi

usage() {
    cat <<EOF
Usage: $0 [options]

Options:
  --device <path>       Specify device manually (e.g., /dev/sda or /dev/nvme0n1)
  --help                Show this help message
EOF
    exit 0
}

# Parse command-line options
while [[ $# -gt 0 ]]; do
    case "$1" in
    --device)
        DEVICE="$2"
        shift 2
        ;;
    --help)
        usage
        ;;
    *)
        echo "Unknown option: $1" >&2
        usage
        ;;
    esac
done

has_partition_table() {
    local device="$1"
    if [[ -z "$device" || ! -b "$device" ]]; then
        echo "‚ùå $device is not a block device." >&2
        return 1
    fi

    if sudo parted -s "$device" print &>/dev/null; then
        echo "true"
    else
        echo "false"
    fi
}

is_device_mounted() {
    local device="$1"
    if mount | grep -q "^$device "; then
        echo "true"
    else
        echo "false"
    fi
}

get_first_partition() {
    local device="$1"
    sudo lsblk -nrpo NAME "$device" | grep -v "^$device\$" | head -n 1
}

get_filesystem_type() {
    local part="$1"

    if [[ -z "$part" || ! -b "$part" ]]; then
        echo ""
        return
    fi

    sudo blkid -s TYPE -o value "$part"
}

wait_for_partition() {
    local device="$1"
    for i in {1..10}; do
        local part
        part=$(get_first_partition "$device")
        if [[ -n "$part" && -b "$part" ]]; then
            echo "$part"
            return
        fi
        sleep 0.5
    done
    echo ""
}

prompt_for_filesystem_type() {
    read -p "‚ùì Use Windows-compatible filesystem (exfat)? [y/N] " winfs
    if [[ "$winfs" == [yY] ]]; then
        FS_TYPE_ARG="exfat"
    else
        FS_TYPE_ARG="ext4"
    fi
    MAKE_FS=true
}

if [[ -z "$DEVICE" ]]; then
    echo "‚ùå --device must be specified."
    exit 1
fi

if ! [[ -b "$DEVICE" ]]; then
    echo "‚ùå $DEVICE is not a block device."
    exit 1
fi

if [[ "$(is_device_mounted "$DEVICE")" == "true" ]]; then
    echo "‚ö†Ô∏è  Device $DEVICE is currently mounted."

    read -p "‚ùì Unmount $DEVICE before proceeding? [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        echo "üîß Unmounting $DEVICE..."
        if sudo umount "$DEVICE"; then
            echo "‚úÖ Unmounted"
        else
            echo "‚ùå Failed to unmount $DEVICE ‚Äî it may be busy."
            echo "   Tip: Run \`lsof +f -- $DEVICE\` or \`mount | grep $DEVICE\` to investigate."
            exit 1
        fi
    else
        echo "‚ùå Aborting. Cannot proceed with mounted device."
        exit 1
    fi
fi

# PARTITION TABLE LOGIC
if has_partition_table "$DEVICE"; then
    echo "‚úÖ Partition table found on $DEVICE"

    echo "üìÑ Current partition table:"
    sudo lsblk -o NAME,SIZE,FSTYPE,LABEL,UUID,MOUNTPOINT "$DEVICE"

    read -p "‚ùì Overwrite existing partition table on $DEVICE with a new GPT table? This will erase all data. [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        create_table=true
    else
        echo "‚û°Ô∏è  Keeping existing partition table."
        create_table=false
    fi
else
    echo "‚ö†Ô∏è  No partition table found on $DEVICE"

    read -p "‚ùì Create a new GPT partition table on $DEVICE? This will erase all data. [Y/n] " confirm
    if [[ "$confirm" == [nN] ]]; then
        echo "‚ùå Aborting. No changes made."
        exit 1
    fi
    create_table=true
fi

if [[ "$create_table" == true ]]; then
    echo "üõ†Ô∏è  Creating GPT partition table and a single primary partition..."
    sudo parted -s "$DEVICE" mklabel gpt
    sudo parted -s -a optimal "$DEVICE" mkpart primary 0% 100%
    sync
    echo "‚úÖ Partition table is ready"
    echo "üåÄ Informing kernel of partition changes..."
    sudo partprobe "$DEVICE" || sudo udevadm settle
    sleep 1
fi

# Wait for partition
PARTITION=$(wait_for_partition "$DEVICE")
if [[ -z "$PARTITION" ]]; then
    echo "‚ùå Could not find partition on $DEVICE"
    exit 1
fi

# FILESYSTEM LOGIC
fstype=$(get_filesystem_type "$PARTITION")

if [[ -n "$fstype" ]]; then
    echo "‚úÖ Detected existing filesystem: $fstype"

    read -p "‚ùì Do you want to overwrite it with a new filesystem? This will erase all data. [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        prompt_for_filesystem_type
    else
        echo "‚û°Ô∏è  Keeping existing filesystem. Continuing without changes."
    fi
else
    echo "‚ÑπÔ∏è  No filesystem detected on $PARTITION."

    read -p "‚ùì Create new filesystem? [Y/n] " confirm
    if [[ "$confirm" == [nN] ]]; then
        echo "‚ùå Aborting. No filesystem will be created."
        exit 1
    fi

    prompt_for_filesystem_type
fi

if [[ "$MAKE_FS" == true ]]; then
    echo "üßº Creating $FS_TYPE_ARG filesystem on $PARTITION..."

    case "$FS_TYPE_ARG" in
    ext4)
        sudo mkfs.ext4 -F "$PARTITION"
        ;;
    exfat)
        sudo mkfs.exfat -n SENSOS_DATA "$PARTITION"
        ;;
    *)
        echo "‚ùå Unsupported filesystem type: $FS_TYPE_ARG"
        exit 1
        ;;
    esac

    echo "‚úÖ Filesystem created on $PARTITION"
fi

echo "üìÅ Ensuring mount point exists at $DATA_MOUNT..."
sudo mkdir -p "$DATA_MOUNT"

if [[ -n "$(sudo ls -A "$DATA_MOUNT")" ]]; then
    echo "‚ö†Ô∏è  $DATA_MOUNT is not empty."

    read -p "‚ùì Remove all contents of $DATA_MOUNT before mounting? [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        echo "üßπ Removing existing contents..."
        sudo rm -rf "${DATA_MOUNT:?}/"*
        echo "‚úÖ Directory cleaned"
    else
        read -p "‚ùì Mount device over existing contents anyway? [y/N] " confirm_mount
        if [[ "$confirm_mount" == [yY] ]]; then
            echo "‚û°Ô∏è  Will mount over existing contents at $DATA_MOUNT"
        else
            echo "‚ùå Aborting. Mount point must be clean or explicitly allowed."
            exit 1
        fi
    fi
else
    echo "‚úÖ $DATA_MOUNT is empty and ready."
fi

read -p "‚ùì Proceed with mounting the device? [Y/n] " confirm_mount
if [[ "$confirm_mount" == [nN] ]]; then
    echo "‚ùå Aborting before mount."
    exit 1
fi

echo "üîß Mounting $PARTITION as $FS_TYPE_ARG at $DATA_MOUNT..."
sudo mount "$PARTITION" "$DATA_MOUNT"
echo "‚úÖ Mount complete: $PARTITION ‚Üí $DATA_MOUNT"

echo "üîë Setting permissions on $DATA_MOUNT..."
sudo chown -R sensos-admin:sensos-data "$DATA_MOUNT"
sudo chmod -R g+rwsX "$DATA_MOUNT"
echo "‚úÖ Permissions set"

read -p "‚ùì Make this mount persistent (automatically mounted on boot)? [y/N] " make_persistent
if [[ "$make_persistent" =~ ^[yY]$ ]]; then
    read -p "‚ùì Is this a removable device (e.g., USB stick) that should not be mounted on boot? [y/N] " removable
    if [[ "$removable" =~ ^[yY]$ ]]; then
        SKIP_FSTAB=true
        echo "‚û°Ô∏è  Will skip fstab entry for removable device."
    fi
else
    SKIP_FSTAB=true
    echo "‚û°Ô∏è  Skipping persistent mount as requested."
fi

if [[ "$SKIP_FSTAB" == true ]]; then
    echo "‚è≠Ô∏è  Skipping fstab update."
    exit 0
fi

echo "üìÑ Checking for existing /etc/fstab entry for $PARTITION or $DATA_MOUNT..."

# Refresh UUID and LABEL info in case it changed after mkfs
uuid=$(sudo blkid -s UUID -o value "$PARTITION")
label=$(sudo blkid -s LABEL -o value "$PARTITION")

# If neither UUID nor LABEL is available, fall back to device path
if [[ -z "$uuid" && -z "$label" ]]; then
    echo "‚ö†Ô∏è  No UUID or LABEL found for $PARTITION ‚Äî falling back to using device path in /etc/fstab."
    device_ref="$PARTITION"
else
    if [[ -n "$uuid" ]]; then
        device_ref="UUID=$uuid"
    else
        device_ref="LABEL=$label"
    fi
fi

# Check if an fstab entry already exists
if grep -Eq "^\s*($device_ref|$PARTITION)\s+$DATA_MOUNT\s" /etc/fstab; then
    echo "‚úÖ Found existing fstab entry:"
    grep -E "^\s*($device_ref|$PARTITION)\s+$DATA_MOUNT\s" /etc/fstab

    read -p "‚ùì Keep this fstab entry? [Y/n] " keep
    if [[ "$keep" == [nN] ]]; then
        echo "‚ùå Please edit /etc/fstab manually to remove or update the entry."
        exit 1
    else
        echo "‚úÖ Keeping existing fstab entry."
    fi
else
    echo "‚ÑπÔ∏è  No valid fstab entry found for $PARTITION at $DATA_MOUNT."

    read -p "‚ùì Add new fstab entry to make mount persistent? [Y/n] " add
    if [[ "$add" != [nN] ]]; then
        echo "üîß Adding fstab entry:"
        if [[ "$FS_TYPE_ARG" == "exfat" ]]; then
            fstab_line="$device_ref $DATA_MOUNT exfat defaults,noauto,x-systemd.automount,x-systemd.device-timeout=10 0 0"
        else
            fstab_line="$device_ref $DATA_MOUNT ext4 defaults,noatime 0 2"
        fi
        echo "$fstab_line"
        echo "$fstab_line" | sudo tee -a /etc/fstab >/dev/null
        echo "‚úÖ fstab updated"
    else
        echo "‚û°Ô∏è  Skipping fstab update. Mount will not persist after reboot."
    fi
fi
