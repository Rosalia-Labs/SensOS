#!/bin/bash -e
#
# config-sensos-storage
#
# Mounts external storage to /sensos/data, with safeguards.

script_name=$(basename "$0")
DATA_MOUNT="/sensos/data"

source /sensos/lib/load-defaults.sh
source /sensos/lib/parse-switches.sh

declare -A default_vars
load_defaults "$script_name" default_vars

get_default() {
    local varname="$1"
    local fallback="$2"
    echo "${default_vars[$varname]:-$fallback}"
}

# Register configurable switches
register_option --device "Block device to format/mount" "$(get_default device)"

# Parse CLI
parse_switches "$script_name" "$@"

# Validate
if [[ -z "$device" ]]; then
    echo "âŒ --device must be specified."
    exit 1
fi

has_partition_table() {
    local device="$1"
    if [[ -z "$device" || ! -b "$device" ]]; then
        echo "âŒ $device is not a block device." >&2
        return 1
    fi

    if sudo parted -s "$device" print &>/dev/null; then
        echo "true"
    else
        echo "false"
    fi
}

is_device_mounted() {
    local device="$1"
    if mount | grep -q "^$device "; then
        echo "true"
    else
        echo "false"
    fi
}

get_first_partition() {
    local device="$1"
    sudo lsblk -nrpo NAME "$device" | grep -v "^$device\$" | head -n 1
}

get_filesystem_type() {
    local part="$1"

    if [[ -z "$part" || ! -b "$part" ]]; then
        echo ""
        return
    fi

    sudo blkid -s TYPE -o value "$part"
}

wait_for_partition() {
    local device="$1"
    for i in {1..10}; do
        local part
        part=$(get_first_partition "$device")
        if [[ -n "$part" && -b "$part" ]]; then
            echo "$part"
            return
        fi
        sleep 0.5
    done
    echo ""
}

prompt_for_filesystem_type() {
    read -p "â“ Use Windows-compatible filesystem (exfat)? [y/N] " winfs
    if [[ "$winfs" == [yY] ]]; then
        FS_TYPE_ARG="exfat"
    else
        FS_TYPE_ARG="ext4"
    fi
    MAKE_FS=true
}

if [[ -z "$DEVICE" ]]; then
    echo "âŒ --device must be specified."
    exit 1
fi

if ! [[ -b "$DEVICE" ]]; then
    echo "âŒ $DEVICE is not a block device."
    exit 1
fi

if [[ "$(is_device_mounted "$DEVICE")" == "true" ]]; then
    echo "âš ï¸  Device $DEVICE is currently mounted."

    read -p "â“ Unmount $DEVICE before proceeding? [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        echo "ğŸ”§ Unmounting $DEVICE..."
        if sudo umount "$DEVICE"; then
            echo "âœ… Unmounted"
        else
            echo "âŒ Failed to unmount $DEVICE â€” it may be busy."
            echo "   Tip: Run \`lsof +f -- $DEVICE\` or \`mount | grep $DEVICE\` to investigate."
            exit 1
        fi
    else
        echo "âŒ Aborting. Cannot proceed with mounted device."
        exit 1
    fi
fi

# PARTITION TABLE LOGIC
if has_partition_table "$DEVICE"; then
    echo "âœ… Partition table found on $DEVICE"

    echo "ğŸ“„ Current partition table:"
    sudo lsblk -o NAME,SIZE,FSTYPE,LABEL,UUID,MOUNTPOINT "$DEVICE"

    read -p "â“ Overwrite existing partition table on $DEVICE with a new GPT table? This will erase all data. [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        create_table=true
    else
        echo "â¡ï¸  Keeping existing partition table."
        create_table=false
    fi
else
    echo "âš ï¸  No partition table found on $DEVICE"

    read -p "â“ Create a new GPT partition table on $DEVICE? This will erase all data. [Y/n] " confirm
    if [[ "$confirm" == [nN] ]]; then
        echo "âŒ Aborting. No changes made."
        exit 1
    fi
    create_table=true
fi

if [[ "$create_table" == true ]]; then
    echo "ğŸ› ï¸  Creating GPT partition table and a single primary partition..."
    sudo parted -s "$DEVICE" mklabel gpt
    sudo parted -s -a optimal "$DEVICE" mkpart primary 0% 100%
    sync
    echo "âœ… Partition table is ready"
    echo "ğŸŒ€ Informing kernel of partition changes..."
    sudo partprobe "$DEVICE" || sudo udevadm settle
    sleep 1
fi

# Wait for partition
PARTITION=$(wait_for_partition "$DEVICE")
if [[ -z "$PARTITION" ]]; then
    echo "âŒ Could not find partition on $DEVICE"
    exit 1
fi

# FILESYSTEM LOGIC
fstype=$(get_filesystem_type "$PARTITION")

if [[ -n "$fstype" ]]; then
    echo "âœ… Detected existing filesystem: $fstype"

    read -p "â“ Do you want to overwrite it with a new filesystem? This will erase all data. [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        prompt_for_filesystem_type
    else
        echo "â¡ï¸  Keeping existing filesystem. Continuing without changes."
    fi
else
    echo "â„¹ï¸  No filesystem detected on $PARTITION."

    read -p "â“ Create new filesystem? [Y/n] " confirm
    if [[ "$confirm" == [nN] ]]; then
        echo "âŒ Aborting. No filesystem will be created."
        exit 1
    fi

    prompt_for_filesystem_type
fi

if [[ "$MAKE_FS" == true ]]; then
    echo "ğŸ§¼ Creating $FS_TYPE_ARG filesystem on $PARTITION..."

    case "$FS_TYPE_ARG" in
    ext4)
        sudo mkfs.ext4 -F "$PARTITION"
        ;;
    exfat)
        sudo mkfs.exfat -n SENSOS_DATA "$PARTITION"
        ;;
    *)
        echo "âŒ Unsupported filesystem type: $FS_TYPE_ARG"
        exit 1
        ;;
    esac

    echo "âœ… Filesystem created on $PARTITION"
fi

echo "ğŸ“ Ensuring mount point exists at $DATA_MOUNT..."
sudo mkdir -p "$DATA_MOUNT"

if [[ -n "$(sudo ls -A "$DATA_MOUNT")" ]]; then
    echo "âš ï¸  $DATA_MOUNT is not empty."

    read -p "â“ Remove all contents of $DATA_MOUNT before mounting? [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        echo "ğŸ§¹ Removing existing contents..."
        sudo rm -rf "${DATA_MOUNT:?}/"*
        echo "âœ… Directory cleaned"
    else
        read -p "â“ Mount device over existing contents anyway? [y/N] " confirm_mount
        if [[ "$confirm_mount" == [yY] ]]; then
            echo "â¡ï¸  Will mount over existing contents at $DATA_MOUNT"
        else
            echo "âŒ Aborting. Mount point must be clean or explicitly allowed."
            exit 1
        fi
    fi
else
    echo "âœ… $DATA_MOUNT is empty and ready."
fi

read -p "â“ Proceed with mounting the device? [Y/n] " confirm_mount
if [[ "$confirm_mount" == [nN] ]]; then
    echo "âŒ Aborting before mount."
    exit 1
fi

echo "ğŸ”§ Mounting $PARTITION as $FS_TYPE_ARG at $DATA_MOUNT..."
sudo mount "$PARTITION" "$DATA_MOUNT"
echo "âœ… Mount complete: $PARTITION â†’ $DATA_MOUNT"

echo "ğŸ”‘ Setting permissions on $DATA_MOUNT..."
sudo chown -R sensos-admin:sensos-data "$DATA_MOUNT"
sudo chmod -R g+rwsX "$DATA_MOUNT"
echo "âœ… Permissions set"

read -p "â“ Make this mount persistent (automatically mounted on boot)? [y/N] " make_persistent
if [[ "$make_persistent" =~ ^[yY]$ ]]; then
    read -p "â“ Is this a removable device (e.g., USB stick) that should not be mounted on boot? [y/N] " removable
    if [[ "$removable" =~ ^[yY]$ ]]; then
        SKIP_FSTAB=true
        echo "â¡ï¸  Will skip fstab entry for removable device."
    fi
else
    SKIP_FSTAB=true
    echo "â¡ï¸  Skipping persistent mount as requested."
fi

if [[ "$SKIP_FSTAB" == true ]]; then
    echo "â­ï¸  Skipping fstab update."
    exit 0
fi

echo "ğŸ“„ Checking for existing /etc/fstab entry for $PARTITION or $DATA_MOUNT..."

# Refresh UUID and LABEL info in case it changed after mkfs
uuid=$(sudo blkid -s UUID -o value "$PARTITION")
label=$(sudo blkid -s LABEL -o value "$PARTITION")

# If neither UUID nor LABEL is available, fall back to device path
if [[ -z "$uuid" && -z "$label" ]]; then
    echo "âš ï¸  No UUID or LABEL found for $PARTITION â€” falling back to using device path in /etc/fstab."
    device_ref="$PARTITION"
else
    if [[ -n "$uuid" ]]; then
        device_ref="UUID=$uuid"
    else
        device_ref="LABEL=$label"
    fi
fi

# Check if an fstab entry already exists
if grep -Eq "^\s*($device_ref|$PARTITION)\s+$DATA_MOUNT\s" /etc/fstab; then
    echo "âœ… Found existing fstab entry:"
    grep -E "^\s*($device_ref|$PARTITION)\s+$DATA_MOUNT\s" /etc/fstab

    read -p "â“ Keep this fstab entry? [Y/n] " keep
    if [[ "$keep" == [nN] ]]; then
        echo "âŒ Please edit /etc/fstab manually to remove or update the entry."
        exit 1
    else
        echo "âœ… Keeping existing fstab entry."
    fi
else
    echo "â„¹ï¸  No valid fstab entry found for $PARTITION at $DATA_MOUNT."

    read -p "â“ Add new fstab entry to make mount persistent? [Y/n] " add
    if [[ "$add" != [nN] ]]; then
        echo "ğŸ”§ Adding fstab entry:"
        if [[ "$FS_TYPE_ARG" == "exfat" ]]; then
            fstab_line="$device_ref $DATA_MOUNT exfat defaults,noauto,x-systemd.automount,x-systemd.device-timeout=10 0 0"
        else
            fstab_line="$device_ref $DATA_MOUNT ext4 defaults,noatime 0 2"
        fi
        echo "$fstab_line"
        echo "$fstab_line" | sudo tee -a /etc/fstab >/dev/null
        echo "âœ… fstab updated"
    else
        echo "â¡ï¸  Skipping fstab update. Mount will not persist after reboot."
    fi
fi
