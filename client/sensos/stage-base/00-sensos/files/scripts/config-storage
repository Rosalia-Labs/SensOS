#!/bin/bash -e
#
# config-sensos-storage
#
# Mounts external storage to /sensos/data, with safeguards.

script_name=$(basename "$0")
DATA_MOUNT="/sensos/data"

source /sensos/lib/load-defaults.sh
source /sensos/lib/parse-switches.sh

declare -A default_vars
load_defaults "$script_name" default_vars

get_default() {
    local varname="$1"
    local fallback="$2"
    echo "${default_vars[$varname]:-$fallback}"
}

register_option --device device "Block device to format/mount" "$(get_default device)"
register_option --no-fstab no_fstab "Skip adding fstab entry (non-persistent mount)" "false"

# Parse CLI
parse_switches "$script_name" "$@"

# Validate
if [[ -z "$device" ]]; then
    echo "âŒ --device must be specified."
    exit 1
fi

has_partition_table() {
    local device="$1"
    if [[ -z "$device" || ! -b "$device" ]]; then
        echo "âŒ $device is not a block device." >&2
        return 1
    fi

    if sudo parted -s "$device" print &>/dev/null; then
        echo "true"
    else
        echo "false"
    fi
}

is_device_mounted() {
    local device="$1"
    if mount | grep -q "^$device "; then
        echo "true"
    else
        echo "false"
    fi
}

get_first_partition() {
    local device="$1"
    sudo lsblk -nrpo NAME "$device" | grep -v "^$device\$" | head -n 1
}

get_filesystem_type() {
    local part="$1"

    if [[ -z "$part" || ! -b "$part" ]]; then
        echo ""
        return
    fi

    sudo blkid -s TYPE -o value "$part"
}

wait_for_partition() {
    local device="$1"
    for i in {1..10}; do
        local part
        part=$(get_first_partition "$device")
        if [[ -n "$part" && -b "$part" ]]; then
            echo "$part"
            return
        fi
        sleep 0.5
    done
    echo ""
}

prompt_for_filesystem_type() {
    read -p "â“ Use Windows-compatible filesystem (exfat)? [y/N] " winfs
    if [[ "$winfs" == [yY] ]]; then
        FS_TYPE_ARG="exfat"
    else
        FS_TYPE_ARG="ext4"
    fi
    MAKE_FS=true
}

# Validate device existence
if ! [[ -b "$device" ]]; then
    echo "âŒ $device is not a block device."
    exit 1
fi

# Unmount if necessary
if [[ "$(is_device_mounted "$device")" == "true" ]]; then
    echo "âš ï¸  Device $device is currently mounted."
    read -p "â“ Unmount $device before proceeding? [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        echo "ğŸ”§ Unmounting $device..."
        if sudo umount "$device"; then
            echo "âœ… Unmounted"
        else
            echo "âŒ Failed to unmount $device â€” it may be busy."
            echo "   Tip: Run \`lsof +f -- $device\` or \`mount | grep $device\` to investigate."
            exit 1
        fi
    else
        echo "âŒ Aborting. Cannot proceed with mounted device."
        exit 1
    fi
fi

# PARTITION TABLE LOGIC
if has_partition_table "$device"; then
    echo "âœ… Partition table found on $device"
    echo "ğŸ“„ Current partition table:"
    sudo lsblk -o NAME,SIZE,FSTYPE,LABEL,UUID,MOUNTPOINT "$device"

    read -p "â“ Overwrite existing partition table on $device with a new GPT table? This will erase all data. [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        create_table=true
    else
        echo "â¡ï¸  Keeping existing partition table."
        create_table=false
    fi
else
    echo "âš ï¸  No partition table found on $device"
    read -p "â“ Create a new GPT partition table on $device? This will erase all data. [Y/n] " confirm
    if [[ "$confirm" == [nN] ]]; then
        echo "âŒ Aborting. No changes made."
        exit 1
    fi
    create_table=true
fi

if [[ "$create_table" == true ]]; then
    echo "ğŸ› ï¸  Creating GPT partition table and a single primary partition..."
    sudo parted -s "$device" mklabel gpt
    sudo parted -s -a optimal "$device" mkpart primary 0% 100%
    sync
    echo "âœ… Partition table is ready"
    echo "ğŸŒ€ Informing kernel of partition changes..."
    sudo partprobe "$device" || sudo udevadm settle
    sleep 1
fi

# Wait for partition
PARTITION=$(wait_for_partition "$device")
if [[ -z "$PARTITION" ]]; then
    echo "âŒ Could not find partition on $device"
    exit 1
fi

# FILESYSTEM LOGIC
fstype=$(get_filesystem_type "$PARTITION")
if [[ -n "$fstype" ]]; then
    echo "âœ… Detected existing filesystem: $fstype"
    read -p "â“ Do you want to overwrite it with a new filesystem? This will erase all data. [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        prompt_for_filesystem_type
    else
        echo "â¡ï¸  Keeping existing filesystem. Continuing without changes."
        FS_TYPE_ARG="$fstype"
        MAKE_FS=false
    fi
else
    echo "â„¹ï¸  No filesystem detected on $PARTITION."
    read -p "â“ Create new filesystem? [Y/n] " confirm
    if [[ "$confirm" == [nN] ]]; then
        echo "âŒ Aborting. No filesystem will be created."
        exit 1
    fi
    prompt_for_filesystem_type
fi

if [[ "$MAKE_FS" == true ]]; then
    echo "ğŸ§¼ Creating $FS_TYPE_ARG filesystem on $PARTITION..."
    case "$FS_TYPE_ARG" in
    ext4)
        sudo mkfs.ext4 -F "$PARTITION"
        ;;
    exfat)
        sudo mkfs.exfat -n SENSOS_DATA "$PARTITION"
        ;;
    *)
        echo "âŒ Unsupported filesystem type: $FS_TYPE_ARG"
        exit 1
        ;;
    esac
    echo "âœ… Filesystem created on $PARTITION"
fi

# Ensure mount point exists with correct ownership before mounting
echo "ğŸ“ Ensuring mount point exists at $DATA_MOUNT..."
sudo mkdir -p "$DATA_MOUNT"
# Set mount point ownership in advance for ext4 mounts.
sudo chown sensos-admin:sensos-data "$DATA_MOUNT"
sudo chmod g+rws "$DATA_MOUNT"
# Ensure microenv subdir exists and is writable by sensos-runner
sudo mkdir -p "$DATA_MOUNT/microenv"
sudo chown -R sensos-runner:sensos-data "$DATA_MOUNT/microenv"
sudo chmod -R g+rwsX "$DATA_MOUNT/microenv"

# If mount point is not empty, prompt to clean it up (warn user)
if [[ -n "$(sudo ls -A "$DATA_MOUNT")" ]]; then
    echo "âš ï¸  $DATA_MOUNT is not empty."
    read -p "â“ Remove all contents of $DATA_MOUNT before mounting? [y/N] " confirm
    if [[ "$confirm" == [yY] ]]; then
        echo "ğŸ§¹ Removing existing contents..."
        sudo rm -rf "${DATA_MOUNT:?}/"*
        echo "âœ… Directory cleaned"
    else
        read -p "â“ Mount device over existing contents anyway? [y/N] " confirm_mount
        if [[ "$confirm_mount" == [yY] ]]; then
            echo "â¡ï¸  Will mount over existing contents at $DATA_MOUNT"
        else
            echo "âŒ Aborting. Mount point must be clean or explicitly allowed."
            exit 1
        fi
    fi
else
    echo "âœ… $DATA_MOUNT is empty and ready."
fi

read -p "â“ Proceed with mounting the device? [Y/n] " confirm_mount
if [[ "$confirm_mount" == [nN] ]]; then
    echo "âŒ Aborting before mount."
    exit 1
fi

echo "ğŸ”§ Mounting $PARTITION as $FS_TYPE_ARG at $DATA_MOUNT..."
if [[ "$FS_TYPE_ARG" == "exfat" ]]; then
    uid_val=$(id -u sensos-admin)
    gid_val=$(getent group sensos-data | cut -d: -f3)
    sudo mount -t exfat -o uid="$uid_val",gid="$gid_val",umask=0002 "$PARTITION" "$DATA_MOUNT"
else
    sudo mount "$PARTITION" "$DATA_MOUNT"
    sudo chown -R sensos-admin:sensos-data "$DATA_MOUNT"
    sudo chmod -R g+rwsX "$DATA_MOUNT"
    echo "âœ… Permissions set"
fi
echo "âœ… Mount complete: $PARTITION â†’ $DATA_MOUNT"

if [[ -n "$(sudo ls -A "$DATA_MOUNT")" ]]; then
    echo "âš ï¸  Files exist on $DATA_MOUNT after mounting."
    echo "â“ Choose what to remove:"
    echo "   [a] All contents of $DATA_MOUNT"
    echo "   [d] Only $DATA_MOUNT/database"
    echo "   [s] Skip (do not delete anything)"
    read -p "Your choice [a/d/s]? " cleanup_choice

    # Mountpoint check for all delete options:
    if [[ "$cleanup_choice" =~ [aAdD] ]]; then
        if ! mountpoint -q "$DATA_MOUNT"; then
            echo "âŒ $DATA_MOUNT is not a mountpoint! Aborting cleanup to avoid deleting files from the root filesystem."
            exit 1
        fi
    fi

    case "$cleanup_choice" in
    a | A)
        read -p "â— Are you sure you want to permanently delete ALL contents of $DATA_MOUNT? [y/N] " confirm_all
        if [[ "$confirm_all" == [yY] ]]; then
            echo "ğŸ§¹ Removing ALL contents of $DATA_MOUNT..."
            sudo rm -rf "${DATA_MOUNT:?}/"*
            echo "âœ… All contents removed."
        else
            echo "âŒ Skipped deletion of all contents."
        fi
        ;;
    d | D)
        if [[ -d "$DATA_MOUNT/database" ]]; then
            read -p "â— Are you sure you want to delete $DATA_MOUNT/database? [y/N] " confirm_db
            if [[ "$confirm_db" == [yY] ]]; then
                echo "ğŸ§¹ Removing $DATA_MOUNT/database..."
                sudo rm -rf "$DATA_MOUNT/database"
                echo "âœ… database directory removed."
            else
                echo "âŒ Skipped deletion of database."
            fi
        else
            echo "â„¹ï¸  $DATA_MOUNT/database does not exist â€” nothing to remove."
        fi
        ;;
    *)
        echo "â¡ï¸  Skipping deletion."
        ;;
    esac
fi

if [[ "$no_fstab" == "true" ]]; then
    echo "â­ï¸  Skipping fstab update (flag --no-fstab was set)."
    exit 0
fi

echo "ğŸ“„ Checking for existing /etc/fstab entry for $PARTITION or $DATA_MOUNT..."
# Refresh UUID and LABEL info in case it changed after mkfs
uuid=$(sudo blkid -s UUID -o value "$PARTITION")
label=$(sudo blkid -s LABEL -o value "$PARTITION")
if [[ -z "$uuid" && -z "$label" ]]; then
    echo "âš ï¸  No UUID or LABEL found for $PARTITION â€” falling back to using device path in /etc/fstab."
    device_ref="$PARTITION"
else
    if [[ -n "$uuid" ]]; then
        device_ref="UUID=$uuid"
    else
        device_ref="LABEL=$label"
    fi
fi

if grep -Eq "^\s*(${device_ref}|${PARTITION})\s+${DATA_MOUNT}\s" /etc/fstab; then
    echo "âœ… Found existing fstab entry:"
    grep -n -E "^\s*(${device_ref}|${PARTITION})\s+${DATA_MOUNT}\s" /etc/fstab
    read -p "â“ Keep this fstab entry? [Y/n] " keep
    if [[ "$keep" == [nN] ]]; then
        echo "âŒ Please edit /etc/fstab manually to remove or update the entry (see above for line number)."
        exit 1
    else
        echo "âœ… Keeping existing fstab entry."
    fi
else
    echo "â„¹ï¸  No valid fstab entry found for $PARTITION at $DATA_MOUNT."
    read -p "â“ Add new fstab entry to make mount persistent? [Y/n] " add
    if [[ "$add" != [nN] ]]; then
        echo "ğŸ§¹ Removing any existing /etc/fstab entry for $DATA_MOUNT..."
        sudo sed -i.bak -r "\|^[^#].+\s+$DATA_MOUNT\s+|d" /etc/fstab
        echo "ğŸ”§ Adding fstab entry:"
        if [[ "$FS_TYPE_ARG" == "exfat" ]]; then
            uid_val=$(id -u sensos-admin)
            gid_val=$(getent group sensos-data | cut -d: -f3)
            fstab_line="$device_ref $DATA_MOUNT exfat defaults,nofail,uid=$uid_val,gid=$gid_val,umask=0002,noauto,x-systemd.automount,x-systemd.device-timeout=10 0 0"
        else
            fstab_line="$device_ref $DATA_MOUNT ext4 defaults,nofail,noatime 0 2"
        fi
        echo "$fstab_line"
        echo "$fstab_line" | sudo tee -a /etc/fstab >/dev/null
        echo "âœ… fstab updated"
    else
        echo "â¡ï¸  Skipping fstab update. Mount will not persist after reboot."
    fi
fi
