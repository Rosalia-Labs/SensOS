#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Rosalia Labs

# config-modem
# - Creates/updates a NetworkManager GSM profile for the given provider
# - Sets autoconnect based on CONNECTIVITY_MODE from /sensos/etc/network.conf
# - If BANDWIDTH_POLICY=restricted, locks the modem device to WG (UDP WG_ENDPOINT_PORT) + DHCP + ESTABLISHED/RELATED
# - Optional bandwidth caps via tc (egress/ingress)

set -euo pipefail

script_name=$(basename "$0")
network_conf="/sensos/etc/network.conf"

# ----------------------- enforce user / sudo -----------------------
if [[ "$(id -un)" != "sensos-admin" ]]; then
  echo "ERROR: this script must be run as sensos-admin." >&2
  exit 1
fi

# ----------------------- early help (avoid parse-switches under set -u) -----------------------
print_usage() {
  cat <<EOF
Usage: $script_name [options]

Options:
  --service [value]          Cellular provider (e.g. 1nce, Soracom)
  --device  [value]          NetworkManager control port (e.g. cdc-wdm0 or ttyUSB2) (default: cdc-wdm0)
  --start   [true|false]     Immediately bring modem online after config (default: false)
  --limit-up-kbit [value]    Egress cap in kbit (optional)
  --limit-down-kbit [value]  Ingress cap in kbit (optional)
  -h, --help                 Show this help and exit
EOF
}

for arg in "$@"; do
  if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
    print_usage
    exit 0
  fi
done

# ----------------------- deps -----------------------
if ! command -v nmcli >/dev/null 2>&1; then
  echo "ERROR: nmcli not found. Install NetworkManager." >&2
  exit 1
fi

source /sensos/lib/load-defaults.sh
source /sensos/lib/parse-switches.sh

declare -A default_vars
load_defaults "$script_name" default_vars

get_default() {
  local varname="$1"
  local fallback="${2-}"
  echo "${default_vars[$varname]:-$fallback}"
}

# ----------------------- options -----------------------
register_option --service service "Cellular provider (e.g. 1nce, Soracom)" "$(get_default service)"
# default to control port, not data iface
register_option --device device "NetworkManager device/control port (e.g. cdc-wdm0 or ttyUSB2)" "$(get_default device cdc-wdm0)"
register_option --start start_now "Immediately bring modem online after config" "$(get_default start_now false)"
# Optional bandwidth limits (kbit)
register_option --limit-up-kbit   limit_up_kbit   "Egress cap in kbit (optional)"   "$(get_default limit_up_kbit "")"
register_option --limit-down-kbit limit_down_kbit "Ingress cap in kbit (optional)" "$(get_default limit_down_kbit "")"

# Guard parse-switches from nounset issues inside its help path
set +u
parse_switches "$script_name" "$@"
set -u

if [[ -z "${service:-}" ]]; then
  echo "ERROR: --service must be specified." >&2
  exit 1
fi

# ----------------------- config -----------------------
if [[ ! -f "$network_conf" ]]; then
  echo "ERROR: Required config $network_conf is missing." >&2
  exit 1
fi

# shellcheck disable=SC1090
source "$network_conf"

CONNECTIVITY_MODE="${CONNECTIVITY_MODE:-manual}"
BANDWIDTH_POLICY="${BANDWIDTH_POLICY:-}"
WG_ENDPOINT_PORT="${WG_ENDPOINT_PORT:-}"

if [[ "${BANDWIDTH_POLICY,,}" == "restricted" && -z "$WG_ENDPOINT_PORT" ]]; then
  echo "ERROR: BANDWIDTH_POLICY=restricted but WG_ENDPOINT_PORT is not set in $network_conf." >&2
  exit 1
fi

# ----------------------- provider â†’ APN -----------------------
case "$service" in
  1nce|1NCE)         apn="iot.1nce.net" ;;
  Soracom|soracom)   apn="soracom.io" ;;
  *)
    echo "ERROR: Unsupported service '$service'." >&2
    exit 1
    ;;
esac

nm_con_name="sensos-$service"

# If user passed a data iface like wwan0, nudge to control port
if [[ "${device}" == wwan* ]]; then
  echo "NOTE: '$device' looks like a data interface. Using control port 'cdc-wdm0' instead."
  device="cdc-wdm0"
fi

# Data iface used for tc/iptables if a control port is used
data_iface="$device"
if [[ "$device" == cdc-wdm* || "$device" == ttyUSB* ]]; then
  data_iface="wwan0"
fi

# ----------------------- NM connection -----------------------
if nmcli -t -f NAME con show | grep -qx "$nm_con_name"; then
  echo "Updating connection '$nm_con_name' for device '$device'..."
  sudo nmcli con mod "$nm_con_name" gsm.apn "$apn" || true
  sudo nmcli con mod "$nm_con_name" connection.id "$nm_con_name" || true
  sudo nmcli con mod "$nm_con_name" connection.interface-name "$device" || true
else
  echo "Creating connection '$nm_con_name' on device '$device'..."
  sudo nmcli con add type gsm ifname "$device" con-name "$nm_con_name" apn "$apn"
fi

sudo nmcli con mod "$nm_con_name" ipv4.method auto   || true
sudo nmcli con mod "$nm_con_name" ipv6.method ignore || true

if [[ "$CONNECTIVITY_MODE" == "always" ]]; then
  sudo nmcli con mod "$nm_con_name" connection.autoconnect yes
  echo "Autoconnect enabled (CONNECTIVITY_MODE=always)."
else
  sudo nmcli con mod "$nm_con_name" connection.autoconnect no
  echo "Autoconnect disabled (CONNECTIVITY_MODE=$CONNECTIVITY_MODE)."
fi

# ----------------------- tc limits -----------------------
apply_tc_limits() {
  local dev="$1" up_kbit="${2:-}" down_kbit="${3:-}"

  if [[ -n "${up_kbit}" ]]; then
    echo "Applying egress cap ${up_kbit} kbit on ${dev}..."
    sudo tc qdisc del dev "$dev" root 2>/dev/null || true
    sudo tc qdisc add dev "$dev" root tbf rate "${up_kbit}kbit" burst 32kbit latency 400ms
  fi

  if [[ -n "${down_kbit}" ]]; then
    echo "Applying ingress cap ${down_kbit} kbit on ${dev}..."
    sudo tc qdisc del dev "$dev" handle ffff: ingress 2>/dev/null || true
    sudo tc qdisc add dev "$dev" handle ffff: ingress
    sudo tc filter add dev "$dev" parent ffff: protocol all u32 \
      match u32 0 0 police rate "${down_kbit}kbit" burst 32k drop flowid :1
  fi
}

if [[ -n "${limit_up_kbit:-}" || -n "${limit_down_kbit:-}" ]]; then
  apply_tc_limits "$data_iface" "${limit_up_kbit:-}" "${limit_down_kbit:-}"
fi

# ----------------------- lockdown fragments (restricted policy) -----------------------
write_lockdown_fragments() {
  local dev="$1"        # e.g., wwan0
  local wg_port="$2"    # WireGuard UDP port
  local dir="/sensos/etc/iptables"
  mkdir -p "$dir"

  # ---- IPv4 fragment ----
  local v4="$dir/30-lockdown-${dev}.rules.v4"
  cat >"$v4" <<EOF
*filter
:SENSOS_LOCKDOWN_${dev}_IN - [0:0]
:SENSOS_LOCKDOWN_${dev}_OUT - [0:0]
:SENSOS_LOCKDOWN_${dev}_FWD - [0:0]
-A SENSOS_LOCKDOWN_${dev}_IN  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A SENSOS_LOCKDOWN_${dev}_IN  -p udp --sport 67 --dport 68 -j ACCEPT
-A SENSOS_LOCKDOWN_${dev}_IN  -p udp --dport ${wg_port} -j ACCEPT
-A SENSOS_LOCKDOWN_${dev}_IN  -j REJECT --reject-with icmp-port-unreachable
-A SENSOS_LOCKDOWN_${dev}_OUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A SENSOS_LOCKDOWN_${dev}_OUT -p udp --sport 68 --dport 67 -j ACCEPT
-A SENSOS_LOCKDOWN_${dev}_OUT -p udp --dport ${wg_port} -j ACCEPT
-A SENSOS_LOCKDOWN_${dev}_OUT -p udp --dport 123 -j ACCEPT
-A SENSOS_LOCKDOWN_${dev}_OUT -p icmp --icmp-type echo-request -j ACCEPT
-A SENSOS_LOCKDOWN_${dev}_OUT -j REJECT --reject-with icmp-port-unreachable
-A SENSOS_LOCKDOWN_${dev}_FWD -j REJECT --reject-with icmp-port-unreachable
-I INPUT 1  -i ${dev} -j SENSOS_LOCKDOWN_${dev}_IN
-I OUTPUT 1 -o ${dev} -j SENSOS_LOCKDOWN_${dev}_OUT
-I FORWARD 1 -o ${dev} -j SENSOS_LOCKDOWN_${dev}_FWD
COMMIT
EOF

  # ---- IPv6 fragment ----
  # Your NM config ignores IPv6 on the uplink; this still safely blocks if v6 appears.
  local v6="$dir/30-lockdown-${dev}.rules.v6"
  cat >"$v6" <<EOF
*filter
:SENSOS_LOCKDOWN_'"$dev"'_IN6 - [0:0]
:SENSOS_LOCKDOWN_'"$dev"'_OUT6 - [0:0]
:SENSOS_LOCKDOWN_'"$dev"'_FWD6 - [0:0]
-A SENSOS_LOCKDOWN_'"$dev"'_IN6  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
# (no DHCPv6 because IPv6 is ignored for uplink)
# Allow WG over v6 if you ever use it:
-A SENSOS_LOCKDOWN_'"$dev"'_IN6  -p udp --dport '"$wg_port"' -j ACCEPT
-A SENSOS_LOCKDOWN_'"$dev"'_IN6  -j REJECT
-A SENSOS_LOCKDOWN_'"$dev"'_OUT6 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A SENSOS_LOCKDOWN_'"$dev"'_OUT6 -p udp --dport '"$wg_port"' -j ACCEPT
-A SENSOS_LOCKDOWN_'"$dev"'_OUT6 -p udp --dport 123 -j ACCEPT
-A SENSOS_LOCKDOWN_'"$dev"'_OUT6 -p ipv6-icmp -j ACCEPT
-A SENSOS_LOCKDOWN_'"$dev"'_OUT6 -j REJECT
-A SENSOS_LOCKDOWN_'"$dev"'_FWD6 -j REJECT
-I INPUT 1  -i '"$dev"' -j SENSOS_LOCKDOWN_'"$dev"'_IN6
-I OUTPUT 1 -o '"$dev"' -j SENSOS_LOCKDOWN_'"$dev"'_OUT6
-I FORWARD 1 -o '"$dev"' -j SENSOS_LOCKDOWN_'"$dev"'_FWD6
COMMIT
EOF

  echo "Wrote lockdown fragments:"
  echo "  $v4"
  echo "  $v6"
  echo "Restore at boot will apply these after SSH allow."
}

if [[ "${BANDWIDTH_POLICY,,}" == "restricted" ]]; then
  write_lockdown_fragments "$data_iface" "$WG_ENDPOINT_PORT"
fi

# ----------------------- vnstat registration -----------------------
if command -v vnstat >/dev/null 2>&1; then
  if ip link show "$data_iface" >/dev/null 2>&1; then
    # If no database yet for $data_iface, create it (vnStat v2.x), else noop.
    if ! vnstat -i "$data_iface" --oneline >/dev/null 2>&1; then
      if vnstat --help 2>/dev/null | grep -q -- '--create'; then
        echo "Creating vnStat database for $data_iface..."
        sudo vnstat --create -i "$data_iface"
      else
        echo "Adding vnStat interface $data_iface (legacy vnStat 1.x)..."
        sudo vnstat --add -i "$data_iface"
      fi
    fi
    # Ensure the collector is running so stats actually accrue.
    if command -v systemctl >/dev/null 2>&1; then
      sudo systemctl enable --now vnstat >/dev/null 2>&1 || true
    fi
  else
    echo "WARNING: interface $data_iface not present yet; skipping vnStat registration." >&2
  fi
else
  echo "WARNING: vnstat not installed; cannot track usage on $data_iface." >&2
fi

# ----------------------- start now? -----------------------
if [[ "${start_now}" == "true" ]]; then
  echo "Bringing up modem connection '$nm_con_name' via '$device'..."
  if ! sudo nmcli -w 45 con up "$nm_con_name" ifname "$device"; then
    echo "WARNING: Failed to start modem connection '$nm_con_name' (ifname=$device)." >&2
  fi
fi

echo "Done."
echo "Manage the modem with:"
echo "  sudo nmcli con up   $nm_con_name"
echo "  sudo nmcli con down $nm_con_name"
